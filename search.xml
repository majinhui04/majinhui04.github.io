<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从0开始发布一个无依赖、高质量的 npm 包]]></title>
    <url>%2Fweb-advance%2Fnpm-package%2F</url>
    
      <content type="text"><![CDATA[写在前面没有发布过npm包的同学，可能会对NPM对开发有一种蜜汁敬畏，觉得这是一个很高大上的东西。甚至有次面试，面试官问我有没有发过npm包，当时只用过还没写过，我想应该挺难的，就小声说了没有，然后就让我回去了o(╯□╰)o。 其实，在现在的我看来，npm包就是一个我们平时经常写的一个export出来的模块而已，只不过跟其它业务代码耦合性低，具有较高的独立性。 当然，要发布一个npm包，除了写的模块组件外，还需要做一些基础的包装工作。下面我就以最近开发的「DigitalKeyboard 数字键盘 NPM」 为例，一一列出具体步骤： 1、写基础模块代码； 2、注册npm账号； 3、配置package.json； 4、配置webpack； 5、添加单元测试； 6、完善README.md； 7、发布 1、2、3足可以完成一个npm，4、5、6是为了开发一个高质量的npm。 开始具体代码移步github（https://github.com/simbawus/DigitalKeyboard），请反手 给个 ★ Star ^_~。完整目录结构如下： 12345678910111213141516171819├── LICENSE├── README.md├── build│ └── Keyboard.js├── config│ └── webpack│ ├── webpack.base.config.js│ ├── webpack.config.js│ ├── webpack.dev.config.js│ └── webpack.prod.config.js├── index.html├── package.json├── src│ ├── Keyboard.js│ ├── Keyboard.scss│ └── main.js├── test│ └── Keyboard.test.js└── yarn.lock 基础模块代码现在只需要看src目录下的三个文件。其中，main.js 主要是对将要开发模块的引用，只需存在于开发阶段，同时作为此阶段webpack的入口文件，核心代码在Keyboard.js。 这里，主要用的是ES6的class和export default，Keyboard的核心思想就是点击哪个键就对外输出什么内容，实现也比较简单，大家都能看得懂，这里就不展开讲了，具体可以看github 源码。 注册npm账号这一步也不用说，大家直接去官网注册就好了。 配置package.json 12345678910111213&#123; "name": "digital-keyboard", "version": "1.0.0", "main": "build/Keyboard.js", "repository": "https://github.com/simbawus/DigitalKeyboard.git", "author": "simbawu &lt;connect@simbawu.com&gt;", "description": "DigitalKeyboard Component", "keywords": [ "DigitalKeyboard", "Digital", "Keyboard", ]&#125; 此时的配置文件也比较简单，只需配置npm包名，准备用的名字现在npm搜索一下，已经存在的就不能用了；版本号version，每次发布版本号都需要更新，不然发布不成功；对外export的文件路径，这里我用的是webpack打包后的文件，如果不用webpack，直接引用src/Keyboard.js也可以，只不过要做模块化方式兼容，这个后面说。也可以放上项目所在github地址及作者名，description和keywords比较利于SEO，不过这些都不是必需项。 到这里，一个npm包就开发完成了，直接发布即可使用。但是，略显粗糙：代码压缩、单元测试、readme都没写，别人不知道怎么用也不敢用。下面一步步完善。 配置webpack 这里用的是最新版的webpack4，官方提供production和development两种开发模式，并分别做了默认压缩处理，非常适合这里。有两点要特别说明下： libraryTarget: ‘umd’ umd有的同学可能不是太熟悉，但是cmd、amd大家应该都知道，分别应用于服务端和浏览器端的模块方案。umd就是前面提到的模块化方式兼容。感兴趣可以参考我的另一篇文章JavaScript Module 设计解析及总结。 production和development的entry不一样： development的entry是main.js，而production的entry是Keyboard.js。前面说过，开发阶段需要有对模块的引用，但是正式发布就不需要了，所以要分别配置。 其他就不展开讲了，我的webpack配置结构很清晰，欢迎大家直接copy。 1234├── webpack.base.config.js├── webpack.config.js├── webpack.dev.config.js└── webpack.prod.config.js 添加单元测试大家经常看到很多不错的项目都有，这就像一个证明可用性的证书，给人安全感和信任感，所以添加单元测试，还是很有必要的，同时也可以提高代码质量。先介绍需要用到的几个概念： mocha：测试框架； chai：断言库，断言通俗来讲就是判断代码结果对不对； jsdom：node端是没有js dom对象的，比如window、document等等，所以需要这个库提供； istanbul：代码覆盖率计算工具； coveralls：统计上面的代码测试覆盖率工具； travis-ci：自动集成，比如master代码push到github上之后，travis-ci就会自动进行自动化测试。 这里介绍下jsdom的用法，当时按照几个文档来都跑不通： 123456789101112131415161718192021222324const &#123;JSDOM&#125; = require('jsdom');const &#123;window&#125; = new JSDOM(`&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"&gt; &lt;meta name="author" content="吴胜斌,simbawu"&gt; &lt;title&gt;数字键盘&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="values"&gt;&lt;/div&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;`);propagateToGlobal(window);function propagateToGlobal(window) &#123; for (let key in window) &#123; if (!window.hasOwnProperty(key)) continue; if (key in global) continue; global[key] = window[key]; &#125;&#125; 首先引入jsdom，然后构造一个document，并引入其中的window对象然后一一赋值给node的global对象。其实也很简单，只不过第一次接触，而且找的文档写的也不清楚，所以花了点时间。其他几个文档都还不错，可以看看文档再看看我是怎么用的。此时的package.json就很很丰富了，可以执行yarn test和yarn cover看看测试是否通过及测试覆盖率。 完善README.md一个好的readme是决定用户用不用你项目的关键因素，所以要多花点心思，千万不能忽略。 标题：直观的描述这个项目是干什么的。 徽章： 分别表示是否构建成功、代码测试覆盖率、npm版本号、下载量、开源证书，看起来逼格满满有木有。推荐去shields io 添加，生成一次，之后会自动更新，不过需要等npm发布后才能搜到。 配图：要让用户直观的看到这个组件长什么样，是否满足他的需求。 API介绍：不能让用户猜。 使用示例：尽量降低使用门槛。 发布1234567891011121314151617#先登录NPM账号：npm login#会依次让你输入用户名、密码、和邮箱Username: simbawu Password:Email: (this IS public) wsbin610@163.com#登录成功会出现以下提示信息：Logged in as simbawu on https://registry.npmjs.org/.#执行发布命令：npm publish#发布成功后会出现以下提示信息：+ digital-keyboard@1.0.0#这里digital-keyboard是我的NPM包名，1.0.0是包的版本号 接下来，我们可以在npm官网，通过搜索包名或者在个人中心看到刚刚发布的包。]]></content>
    
      <categories>
        <category>前端进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化]]></title>
    <url>%2Fweb-advance%2Fcomponent%2F</url>
    
      <content type="text"><![CDATA[前端组件化是这几年老生常谈的话题，笔者就不在这里对前端组件化思想的发展史、优劣做详细的介绍。在开发中我们经常会遇到，从初期的小项目，到后期的项目功能迭代，功能模块越来越多，项目越来越大。组件化规范制定不够完善，多人团队协作开发组件耦合度高、复用性低、代码冗余严重，导致项目维护成本越来越高。在此写下笔者自己处理上述问题的思考。 发现、提出问题第 1 版：组件单向数据流，父组件状态单向传向子组件。 第 2 版：随着功能迭代，非父子组件会共享一些状态。此处由于非父子组件间状态共享不复杂，优先使用状态提升（状态提升，我们需要把子组件间共享的状态，提升到容器组件进行管理，并由容器组件下发到子组件）解决此类问题 第 3 版：随着更多的功能迭代，模块分层越来越多，跨多层组件状态共享越来越复杂。 第 4 版：状态管理 redux、vuex 就是为了解决此类问题而出现。 通过以上的项目模块迭代周期的发现，不可避免的会出现多组件状态共享的情况。通常处理共享状态有三种方式： 状态提升，我们需要把子组件间共享的状态，提升到容器组件进行管理，并由容器组件下发到子组件。 状态管理 redux、vuex。 事件机制，子组件改变共享的状态，通过事件管理模块 emit 分发出去，需要同步更改状态的子组件通过 on 接收更改事件。 上述的三种方式会存在哪些问题？ 组件哪些状态需要提取到状态管理？ 如何避免滥用全局状态导致项目混乱？ 容器组件、展示组件如何划分？ 多人协作开发组件规范、风格不统一，组件间共享状态双向修改规则不统一，新人加入学习成本高。 解决问题笔者认为解决问题的方法，就是制定相应规范，保证团队代码规范风格统一。 容器组件与展示组件开发规范。 哪些组件状态应该提取到状态管理，状态管理开发规范。 请看下图： 容器型组件：主要是获取、更新、提交、删除内含展示组件状态数据，不包含任何 DOM 更新。 展示型组件：展示型组件主要表现为组件是怎样渲染的，包含了 Virtual DOM 的修改或组合，也包含组件的样式，同时不依赖任何形式的 store。一般可以写成无状态函数，但实际上由于很多展示型组件里依然存在生命周期方法，所以不一定都是无状态的组件。 说明： 项目初期版本，只有一个容器组件 A，容器 A 包含三个展示组件 A1、A2、A3，所有共享状态都有容器A管理。 随着项目迭代，容器组件 A 会分裂出两个新模块容器组件 B、C。 容器组件 B、C 分别包含展示组件 B1、B2，C1、C2，且 B、C 之间存在共享状态。 容器组件间共享状态数据，统一由状态管理 store 管理。规范： 展示组件必须在容器组件中使用，除了独有的状态，其他共享状态统一由容器组件管理。 展示组件涉及修改共享状态的操作，例如点击事件，需要把点击事件通过无状态回调函数抛到容器组件，由容器组件统一做状态获取、更新、提交、删除等等操作。 父子容器组件共享状态，子容器只能读取父容器组件共享状态，不能进行修改（例如子容器只能通过无状态回调函数抛到父容器），保证单向数据流。 子容器修改父容器或者修改非父子容器共享状态唯一途径，通过状态管理 store 统一修改。 由于容器间共享状态不能双向修改，所以状态管理 store 会保存大量的共享状态数据，需要通过系统模块、容器组件名分层注册需要状态共享的容器组件 state。]]></content>
    
      <categories>
        <category>前端进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装]]></title>
    <url>%2Fgit%2Finstall%2F</url>
    
      <content type="text"><![CDATA[MACMAC可以使用第三方包管理器 HomeBrew 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 开始安装git 1brew install git Linux 可以用自带的yum 1yum install git window下载地址]]></content>
    
      <categories>
        <category>周边</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发规范]]></title>
    <url>%2Fweb-advance%2Fstandard%2F</url>
    
      <content type="text"><![CDATA[敲黑板：文档中命令行未备注则默认是linux系统 环境搭建安装NodeJs 建议 Node.js 版本在 8.0.0 以上 参考：Node安装 安装GIT参考：git安装 项目根目录下配置.gitignore 123456789101112131415161718.DS_Store*.logtmp&#x2F;node_modules&#x2F;dist&#x2F;npm-debug.log*yarn-debug.log*yarn-error.log*package-lock.jsonyarn.lock# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln 配置NPMnpm最容易产生的就是网络问题,我们可以在每次npm下载的时候指定registry，比如 1npm install --registry=https://registry.npm.taobao.org 淘宝npm 推荐IDEVisual Studio（开源免费）下载地址 统一编辑器格式 1234567891011121314# http:&#x2F;&#x2F;editorconfig.orgroot &#x3D; true[*]charset &#x3D; utf-8indent_style &#x3D; spaceindent_size &#x3D; 4end_of_line &#x3D; lfinsert_final_newline &#x3D; truetrim_trailing_whitespace &#x3D; true[*.md]insert_final_newline &#x3D; falsetrim_trailing_whitespace &#x3D; false 项目根目录下新增文件.editorconfig 开发规范基本规范 所有文件的编码格式统一为UTF-8 换行格式为LF tag转为space，默认间隔4个空格 GIT命名 分支功能命名使用snake case命名法，即下划线命名 分支类型包括：feature、bugfix、refactor三种类型，即新功能开发、bug修复和代码重构 分支版本命名规则：比如：ops_v_1_1_0_feature_oeprator Tag包括3位版本，前缀使用v。比如v1.2.31。核心基础库或者大版本发布使用第一位,新功能开发使用第2位版本号，bug修复使用第3位版本号 日志每次提交，Commit message 都包括三个部分：header，body 和 footer。其中，header 是必需的，body 和 footer可以省略。不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; type代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。所有的type类型如下 feat： 新增feature fix: 修复bug docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等 style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor: 代码重构，没有加新功能或者修复bug perf: 优化相关，比如提升性能、体验 test: 测试用例，包括单元测试、集成测试等 chore: 改变构建流程、或者增加依赖库、工具等 revert: 回滚到上一个版本 123456789# 标题行：50个字符以内，描述主要变更内容## 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:## * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等# * 他如何解决这个问题? 具体描述解决问题的步骤# * 是否存在副作用、风险? ## 尾部：如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。 参考Commitizen来添加提交消息格式。 生成 Change log如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分： New features Bug fixes Breaking changes 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 123$ npm install -g conventional-changelog-cli$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w JAVASCRIPT遵循eslint规范 项目根目录新增.eslintrc.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198module.exports = &#123; root: true, parser: 'babel-eslint', parserOptions: &#123; sourceType: 'module' &#125;, env: &#123; browser: true, node: true, es6: true, &#125;, extends: 'eslint:recommended', // required to lint *.vue files plugins: [ 'html' ], // check if imports actually resolve 'settings': &#123; 'import/resolver': &#123; 'webpack': &#123; 'config': 'build/webpack.base.conf.js' &#125; &#125; &#125;, // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue rules: &#123; 'accessor-pairs': 1, 'arrow-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'block-spacing': [2, 'always'], 'brace-style': [2, '1tbs', &#123; 'allowSingleLine': true &#125;], 'camelcase': [0, &#123; 'properties': 'always' &#125;], 'comma-dangle': [2, 'never'], 'comma-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'comma-style': [2, 'last'], 'constructor-super': 2, 'curly': [2, 'multi-line'], 'dot-location': [2, 'property'], 'eol-last': 1, 'eqeqeq': [2, 'allow-null'], 'generator-star-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'handle-callback-err': [2, '^(err|error)$'], 'indent': [2, 4, &#123; 'SwitchCase': 1 &#125;], 'jsx-quotes': [2, 'prefer-single'], 'key-spacing': [2, &#123; 'beforeColon': false, 'afterColon': true &#125;], 'keyword-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'new-cap': [2, &#123; 'newIsCap': true, 'capIsNew': false &#125;], 'new-parens': 2, 'no-array-constructor': 2, 'no-caller': 2, 'no-console': 'off', 'no-class-assign': 2, 'no-cond-assign': 2, 'no-const-assign': 2, 'no-control-regex': 2, 'no-delete-var': 2, 'no-dupe-args': 2, 'no-dupe-class-members': 2, 'no-dupe-keys': 2, 'no-duplicate-case': 2, 'no-empty-character-class': 2, 'no-empty-pattern': 2, 'no-eval': 2, 'no-ex-assign': 2, 'no-extend-native': 2, 'no-extra-bind': 2, 'no-extra-boolean-cast': 2, 'no-extra-parens': [2, 'functions'], 'no-fallthrough': 2, 'no-floating-decimal': 2, 'no-func-assign': 2, 'no-implied-eval': 2, 'no-inner-declarations': [2, 'functions'], 'no-invalid-regexp': 2, 'no-irregular-whitespace': 2, 'no-iterator': 2, 'no-label-var': 2, 'no-labels': [2, &#123; 'allowLoop': false, 'allowSwitch': false &#125;], 'no-lone-blocks': 2, 'no-mixed-spaces-and-tabs': 2, 'no-multi-spaces': 2, 'no-multi-str': 2, 'no-multiple-empty-lines': [2, &#123; 'max': 1 &#125;], 'no-native-reassign': 2, 'no-negated-in-lhs': 2, 'no-new-object': 2, 'no-new-require': 2, 'no-new-symbol': 2, 'no-new-wrappers': 2, 'no-obj-calls': 2, 'no-octal': 2, 'no-octal-escape': 2, 'no-path-concat': 2, 'no-proto': 2, 'no-redeclare': 1, 'no-regex-spaces': 2, 'no-return-assign': [2, 'except-parens'], 'no-self-assign': 2, 'no-self-compare': 2, 'no-sequences': 2, 'no-shadow-restricted-names': 2, 'no-spaced-func': 2, 'no-sparse-arrays': 2, 'no-this-before-super': 2, 'no-throw-literal': 2, 'no-trailing-spaces': 2, 'no-undef': 2, 'no-undef-init': 2, 'no-unexpected-multiline': 2, 'no-unmodified-loop-condition': 2, 'no-unneeded-ternary': [2, &#123; 'defaultAssignment': false &#125;], 'no-unreachable': 2, 'no-unsafe-finally': 2, 'no-unused-vars': [1, &#123; 'vars': 'all', 'args': 'none' &#125;], 'no-useless-call': 2, 'no-useless-computed-key': 2, 'no-useless-constructor': 2, 'no-useless-escape': 0, 'no-whitespace-before-property': 2, 'no-with': 2, 'one-var': [1, &#123; 'initialized': 'never' &#125;], 'operator-linebreak': [2, 'after', &#123; 'overrides': &#123; '?': 'before', ':': 'before' &#125; &#125;], 'padded-blocks': [2, 'never'], 'quotes': [2, 'single', &#123; 'avoidEscape': true, 'allowTemplateLiterals': true &#125;], 'semi': [1, 'always'], 'semi-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'space-before-blocks': [2, 'always'], 'space-before-function-paren': [2, 'never'], 'space-in-parens': [2, 'never'], 'space-infix-ops': 2, 'space-unary-ops': [2, &#123; 'words': true, 'nonwords': false &#125;], 'spaced-comment': [1, 'always', &#123; 'markers': ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ','] &#125;], 'template-curly-spacing': [2, 'never'], 'use-isnan': 2, 'valid-typeof': 2, 'wrap-iife': [2, 'any'], 'yield-star-spacing': [2, 'both'], 'yoda': [2, 'never'], 'prefer-const': 1, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'object-curly-spacing': [1, 'always', &#123; objectsInObjects: false &#125;], 'array-bracket-spacing': [2, 'never'] &#125;&#125; 项目根目录新增.eslintignore 1dist CSS尽量使用类选择器，放弃ID选择器ID在一个页面中的唯一性导致了如果以ID为选择器来写CSS，就无法重用。 分类的命名方法：使用单个字母+”-“为前缀布局（grid）（.g-）；模块（module）（.m-）；元件（unit）（.u-）；功能（function）（.f-）；皮肤（skin）（.s-）；状态（.z-）。 注：在你样式中的选择器总是要以上面前五类开头，然后在里面使用后代选择器。 如果这五类不能满足你的需求，你可以另外定义一个或多个大类，但必须符合单个字母+”-“为前缀的命名规则，即 .x- 的格式。 后代选择器命名 约定不以单个字母+”-“为前缀且长度大于等于2的类选择器为后代选择器，如：.item为m-list模块里的每一个项，.text为m-list模块里的文本部分：.m-list .item{} .m-list .text{}。 一个语义化的标签也可以是后代选择器，比如：.m-list li{}。 不允许单个字母的类选择器出现，原因详见下面的“模块和元件的后代选择器的扩展类”。 12345678/* 这里的.itm和.cnt只在.m-list中有效 */.m-list&#123;margin:0;padding:0;&#125;.m-list .itm&#123;margin:1px;padding:1px;&#125;.m-list .cnt&#123;margin-left:100px;&#125;/* 这里的.cnt和.num只在.m-page中有效 */.m-page&#123;height:20px;&#125;.m-page .cnt&#123;text-align:center;&#125;.m-page .num&#123;border:1px solid #ddd;&#125; 命名应简约而不失语义123456/* 反对：表现化的或没有语义的命名 */.m-abc .green2&#123;&#125;.g-left2&#123;&#125;/* 推荐：使用有语义的简短的命名 */.m-list .wrap2&#123;&#125;.g-side2&#123;&#125; 相同语义的不同类命名方法：直接加数字或字母区分即可（如：.m-list2、.m-list3、.m-list-news、.m-list-banner等，都是列表模块，但是是完全不一样的模块）。 其他举例：.f-fw0、.f-fw1、.s-fc0、.s-fc1、.m-logo2、.m-logo3、u-btn、u-btn2等等。 模块和元件的扩展类的命名方法当A、B、C、…它们类型相同且外形相似区别不大，那么就以它们中出现率最高的做成基类，其他做成基类的扩展。 方法：+“-”+数字或字母（如：.m-list的扩展类为.m-list-1、.m-list-2等）。补充：基类自身可以独立使用（如：class=”m-list”即可），扩展类必须基于基类使用（如：class=”m-list m-list-2”）。 最佳实践1234567891011121314151617181920/* 这是某个模块 */.m-nav&#123;&#125;/* 模块容器 */.m-nav li,.m-nav a&#123;&#125;/* 先共性 优化组合 */.m-nav li&#123;&#125;/* 后个性 语义化标签选择器 */.m-nav a&#123;&#125;/* 后个性中的共性 按结构顺序 */.m-nav a.a1&#123;&#125;/* 后个性中的个性 */.m-nav a.a2&#123;&#125;/* 后个性中的个性 */.m-nav .z-crt a&#123;&#125;/* 交互状态变化 */.m-nav .z-crt a.a1&#123;&#125;.m-nav .z-crt a.a2&#123;&#125;.m-nav .btn&#123;&#125;/* 典型后代选择器 */.m-nav .btn-1&#123;&#125;/* 典型后代选择器扩展 */.m-nav .btn-dis&#123;&#125;/* 典型后代选择器扩展（状态） */.m-nav .btn.z-dis&#123;&#125;/* 作用同上，请二选一（如果可以不兼容IE6时使用） */.m-nav .m-sch&#123;&#125;/* 控制内部其他模块位置 */.m-nav .u-sel&#123;&#125;/* 控制内部其他元件位置 */.m-nav-1&#123;&#125;/* 模块扩展 */.m-nav-1 li&#123;&#125;.m-nav-dis&#123;&#125;/* 模块扩展（状态） */.m-nav.z-dis&#123;&#125;/* 作用同上，请二选一（如果可以不兼容IE6时使用） */ 统一语义理解和命名布局（.g-） 语义 命名 文档 doc 头部 head 主体 body 尾部 foot 主栏 main 主栏子容器 mainc 侧栏 side 侧栏主容器 sidec 盒容器 wrap/box 模块（.m-）、元件（.u-） 语义 命名 导航 nav 子导航 subnav 面包屑 crumb 菜单 menu 选项卡 tag 标题区 headline 内容区 content 列表 list 表格 table 表单 form 热点 hot 排行 top 登录 login 标志 logo 广告 advertise 搜索 search 幻灯 slide 提示 tips 帮助 help 新闻 news 下载 download 注册 regist 投票 vote 版权 copyright 结果 result 按钮 button 输入 input 感谢 世界上最好的语言 JavaScript 啥都能做的前端构建工具 Webpack 简单好用的文档展示工具 Docute]]></content>
    
      <categories>
        <category>前端进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离、web 与 static 服务器分离]]></title>
    <url>%2Fweb-advance%2F1%2F</url>
    
      <content type="text"><![CDATA[1. 为什么需要 “前后端分离、web 与 static 服务器分离”web 前端的发展历史大致可以分为两个阶段：node 之前与 node 之后。在 nodejs 出现之前，前端的发展一直比较缓慢，主要是因为： html/css/js 从设计之初开始，都只为浏览器服务，并且在整个 web 程序中，是以后端为主，前端为辅，前端需要配合不同的后端做出调整（如不同后端语言的模板），因此前端程序往往是与后端程序耦合在一起的； 开发、调试、运行都始终摆脱不了浏览器，并且没有多少可选的工具（如 combo，都是由后端语言在服务器端实现的），不能自动化、工程化的构建前端的代码； 由于浏览器的运行方式，前端代码一直不能有效的做到模块化、组件化，项目也无法版本化管理，项目间也不能很好的共享代码； 浏览器运行速度低下，也是早期前端发展的一大障碍，但 chromium 项目的出现，让前端的运行架上了高铁的速度。 基于以上的原因，前端一直不能很好的开发大型应用，所以在 web 程序中，前端一直处于配角的角色。在 nodejs 出现之后，前端的发展迎来了质的飞跃，带来了我们当时无法想象的便利与潜力。 node 拓展了 javascript 的运行环境，并且能够开发服务器端程序，这让前端的开发和运行摆脱对浏览器和后端语言的依赖，让它们成为了可选项； node 使 javascript 拥有了操作本地文件、IO 等权限，于是前端开发人员便可编写各类工具，前端便可做到自动化和工程化； 再结合 npm，前端代码的模块化、组件化，项目版本化，项目间共享代码也就不是问题了。 nodejs 出现了之后，又陆续出现了扩展前端运行领域的工具，如 electron, nw.js: 让前端可以开发桌面软件； react-native: 让前端可以开发原生 app。 随着 node 的出现与前端的发展，工程化自动构建便成了开发人员的一个基本需求，这便是我要说的 “前后端分离、web 与 static 服务器分离”； 2. 前后端分离前后端分离，就是让前端与后端解耦，开发和运行都不再耦合在一起。这样，前端开发人员便可更好的掌控自己的代码，对自己的代码进行调试，优化等等。 2.1 工程分离首先是工程的分离，也就是代码的分离。这就是说让原来前后端融合在一起的项目分离开，前端一个项目，后端一个项目。 以 python 的 django 框架为例： 融合在一起的示例：123456789101112131415161718192021222324252627|-- app&#x2F; # 应用主目录 |-- templates&#x2F; # html 模板目录 |-- app&#x2F; |-- home.html # 主页html |-- login.html # 登陆页html |-- about.html # 关于页html |-- ... |-- static&#x2F; # 静态资源目录 |-- js&#x2F; # js资源目录 |-- lib&#x2F; # js library 资源目录 |-- page1&#x2F; # 页面1 js资源目录 |-- page2&#x2F; # 页面2 js资源目录 |-- ... |-- css&#x2F; # css资源目录 |-- images&#x2F; # 图片资源目录 |-- ... |-- admin.py # 配置模型models在django原生后台的管理 |-- apps.py # 应用级别的配置 |-- forms.py # 表单处理逻辑 |-- managers.py # 模型处理逻辑 |-- models.py # 模型定义 |-- urls.py # 路由设置 |-- views.py # 控制层 |-- tests.py 分离之后的 django 项目示例：123456789|-- app&#x2F; # 应用主目录 |-- admin.py # 配置模型models在django原生后台的管理 |-- apps.py # 应用级别的配置 |-- forms.py # 表单处理逻辑 |-- managers.py # 模型处理逻辑 |-- models.py # 模型定义 |-- urls.py # 路由设置 |-- views.py # 控制层 |-- tests.py 分离之后的 web 项目示例（以 lila 构建工具为例）：123456789|-- src&#x2F; |-- app&#x2F; |-- home&#x2F; # 主页工作目录 |-- index.html # html 入口文件 |-- index.js # js 入口文件 |-- ... |-- login&#x2F; # 登陆页工作目录 |-- about&#x2F; # 关于页工作目录 |-- ... 本地开发完成后，把构建好的文件传到服务器相应的位置就好了，像上面的例子就需要把 html 文件传到 app/templates 目录下，静态资源文件传到 app/static 目录下。（构建的时候要处理好文件路径引用） 2.2 数据流分离 前后端数据交流使用 json 数据格式，并且推荐使用全 ajax 的方式获取数据，不用传统的模板交流或渲染数据，如 java &gt; jsp、php &gt; smarty； 但有时候为了加快前端响应速度，也可以把 json 数据通过模板返回，但要避免使用后端模板进行逻辑判断渲染。 12345&lt;script&gt;var data &#x3D; JSON.parse(&#39;通过后端模板返回的 json 数据&#39;);&#x2F;&#x2F; 使用 js 渲染 data 数据&lt;&#x2F;script&gt; 3. web 与 static 服务器分离 web 服务器：存放运行后端 web 应用的程序，以及前端 html 文件（入口文件） static 服务器：静态资源服务器，存放前端除 html 文件之外的其他资源文件，包括 js， css， images… 一般地，还是以 django 框架为例，当前端把代码构建好之后，静态资源传到服务器相应的 static 目录，html 文件传到相应的 templates 目录，启动后端脚本就可运行了。两者不分离主要有以下几个缺点： 前端构建过程中会产生大量的冗余文件，这对后端程序来说十分不友好，比如后端打包程序备份的时候，就会导致包很大； 不方便前端开发人员管理线上代码，并且前端人员能够直接接触到后端代码，也不够安全； 静态资源会占用 web 服务器的资源和带宽，当访问量变大的时候，web 与 static 服务器分离是必然的。 web 与 static 服务器分离之后，前端开发人员便可无顾虑的备份前端代码，清除冗余代码等等。 大多数情况下，会有多个项目共用同一个 static 服务器，如此便需要在服务器划分多个目录来存放静态资源文件； 构建的过程中，构建工具需要保证 html 对 js/css/images... 路径的正确引用，以及 css 对 images... 路径的正确引用，以 lila为例，需要配置 staticServerUrl 为 http://www.static.com/project1]]></content>
    
      <categories>
        <category>前端进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 常用命令]]></title>
    <url>%2Fnpm%2F1%2F</url>
    
      <content type="text"><![CDATA[npm 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041npm view moduleNames 或 npm info moduleNames：查看模块的注册信息npm list 或 npm ll 或 npm la 或 npm l：查看所有已经安装的模块npm list parseable&#x3D;true: 可以目录的形式来展现当前安装的所有 node 包npm help：查看帮助命令npm view moudleName dependencies：查看包的依赖关系npm view moduleName repository.url：查看包的源文件地址npm view moduleName engines：查看包所依赖的 Node 的版本npm help folders：查看 npm 使用的所有文件夹 npm rebuild moduleName：用于更改包内容后进行重建 npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新，推荐使用检查依赖包更强大的一个工具[npm-check](https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;npm-check) npm update moduleName 或 npm update -g：更新已经安装的模块(或全局的模块)npm uninstall moudleName：卸载 node 模块 npm help json: 访问 npm 的 json 文件夹,此命令会以默认的方式打开一个网页，如果更改了默认打开程序则可能不会以网页的形式打开npm search packageName:检验某个包名是否已存在npm init：创建一个 package.json 文件，包括名称、版本、作者这些信息等npm root：查看当前包的安装路径npm root -g：查看全局的包的安装路径npm config ls -l：查看和管理 npm 的基础配置npm list --depth&#x3D;0: 查看项目中安装哪些模块npm list --depth --global: 查看全局安装了哪些工具npm list moduleNames： 查看某个模块是否安装了 参考资料npm 常见问题小结 更多关于 npm 资料可参考npm 的 package.json 中文文档 npm入门]]></content>
    
      <categories>
        <category>周边</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装及环境配置之centos篇]]></title>
    <url>%2Fnode%2Finstall%2F</url>
    
      <content type="text"><![CDATA[一、源码包安装首先安装wget如果已经安装了可以跳过该步 1yum install -y wget 1、去官网下载和自己系统匹配的文件通过uname -a命令查看到我的系统位数（备注：x86_64表示64位系统， i686 i386表示32位系统)64位Linux v8.11.3下载地址 1wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v8.11.3&#x2F;node-v8.11.3-linux-x64.tar.xz 2、下载下来的tar解压，然后通过建立软连接变为全局；解压后的文件我这边将名字改为了nodejs，这个解压地方随意（比如/usr/software），只要在建立软连接的时候写正确就可以 123cd /usr/softwaretar xvf node-v8.11.3-linux-x64.tar.xz mv node-v8.11.3-linux-x64 nodejs 3）配置命令 方法一、建立软连接，变为全局 12ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/ 方法二、配置全局变量(注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile) 1vim ~/.bash_profile 在末尾新增 1export PATH=$PATH:/usr/software/nodejs/bin 保存退出:wq 运行生效 1source ~/.bash_profile 4）最后一步检验nodejs是否已变为全局 1node -v ~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. 二、nvm方式安装1curl https:&#x2F;&#x2F;raw.github.com&#x2F;creationix&#x2F;nvm&#x2F;master&#x2F;install.sh | sh 1wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;creationix&#x2F;nvm&#x2F;master&#x2F;install.sh | sh 安装完成后，执行下列命令即可安装 Node.js。 1nvm install stable 12node -vnpm -v 三、yum方式1curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_10.x | bash - 1yum install -y nodejs 12node -vnpm -v]]></content>
    
      <categories>
        <category>周边</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装及环境配置之Mac篇]]></title>
    <url>%2Fnode%2F2%2F</url>
    
      <content type="text"><![CDATA[下载nodejs访问nodejs官网（https://nodejs.org/en/）选择合适，我选择是mac的 安装双击刚下载的.pkg文件，打开之后按照步骤默认安装就行 安装完成之后肯定要检查的，打开终端，分别输入 : 12node-v npm -v 由于node安装的时候就自带npm了。如果出现版本信息，就说明安装成功。 修改全局安装权限1sudo chmod -R 777 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;]]></content>
    
      <categories>
        <category>周边</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装及环境配置之Windows篇]]></title>
    <url>%2Fnode%2F1%2F</url>
    
      <content type="text"><![CDATA[一、安装环境1、本机系统：Windows 10 Pro（64位）2、Node.js：v6.9.2LTS（64位） 二、安装Node.js步骤1、下载对应你系统的Node.js版本: https://nodejs.org/en/download/2、选安装目录进行安装3、环境配置4、测试 三、前期准备1、Node.js简介简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。2、下载Node.js打开官网下载链接:https://nodejs.org/en/download/我这里下载的是node-v6.9.2-x64.msi,如下图： 开始安装 四、测试在键盘按下【win+R】键，输入cmd，然后回车，打开cmd窗口查看版本,如果正常显示则成功了 1node -v]]></content>
    
      <categories>
        <category>周边</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 函数参数推荐书写方式 ({ param1, param2, ... })]]></title>
    <url>%2Fjavascript%2F3%2F</url>
    
      <content type="text"><![CDATA[编程语言函数（包括对象的方法）参数的取值方式大致可以分为两种：按序取值与按名取值。 一般编程语言都是按序取值，比如 C、Java、JavaScript 等，少数语言支持按名取值，比如 Groovy。 1. 按序取值按照顺序，挨个取值，每个参数的顺序是固定的。 123const func &#x3D; (param1, param2, ...) &#x3D;&gt; &#123; ... &#125;func(1, 2, ...) 2. 按名取值按照名称取值，可以任意安排各个参数的顺序。 以下语法并不存在，只是作为讲解生造的 1234const func &#x3D; (param1: value1, param2: value2, ...) &#x3D;&gt; &#123; ... &#125;func(param1: 1, param2: 2); &#x2F;&#x2F; okfunc(param2: 2, param1: 1); &#x2F;&#x2F; ok again 3. js 的按名取值JavaScript 语言本身并不支持按名取值，但结合 ES6 的解构赋值，可以模拟函数参数的按名取值。 123const func &#x3D; (&#123; param1, param2, ... &#125;) &#x3D;&gt; &#123; ... &#125;func(&#123; param1: 1, param2: 2, ... &#125;); 但这种方式如果不传参数调用 func() 就会报错，需要 func({}) 这样调用才表示什么参数都不传。 为了兼容这种方式，可以这样做： 1234const func &#x3D; (&#123; param1, param2, ... &#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123; ... &#125;func(); &#x2F;&#x2F; okfunc(&#123;&#125;); &#x2F;&#x2F; ok again 4. 为什么推荐使用按名取值的方式按名取值最大的好处是可以随意安排参数的顺序，有利于扩展，特别是对 API 接口来说。 比如： 1export const dialog &#x3D; (title, content, confirmCallback, cancelCallback) &#x3D;&gt; &#123; ... &#125; 比如上面的函数中，大部分情况下我只用 content, confirmCallback，那么我就需要这样做： 1dialog(null, &#39;content&#39;, () &#x3D;&gt; &#123; ... &#125;); 如果我需要扩展一个参数 icon， 那么为了兼容以前的版本，我只能加在最后面： 1export const dialog &#x3D; (title, content, confirmCallback, cancelCallback, icon) &#x3D;&gt; &#123; ... &#125; 现在，大部分情况下我只用 content, confirmCallback, icon，那么我就需要这样做： 1dialog(null, &#39;content&#39;, () &#x3D;&gt; &#123; ... &#125;, null, &#39;icon&#39;); 如此，便很麻烦，不利于扩展。 如果使用按名取值的方式，便迎刃而解： 1234export const dialog &#x3D; (&#123;title, content, confirmCallback, cancelCallback&#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123; ... &#125;&#x2F;&#x2F; 扩展 iconexport const dialog &#x3D; (&#123;title, content, icon, confirmCallback, cancelCallback&#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123; ... &#125; 123dialog(&#123;content: &#39;content&#39;, confirmCallback: () &#x3D;&gt; &#123; ... &#125;&#125;);dialog(&#123;content: &#39;content&#39;, icon: &#39;icon&#39;, confirmCallback: () &#x3D;&gt; &#123; ... &#125;&#125;); 5. 大家可能的反驳有人可能会说，可以这样做： 123456789export const dialog &#x3D; (title, content, confirmCallback, cancelCallback) &#x3D;&gt; &#123; if (typeof content &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; cancelCallback &#x3D; confirmCallback; confirmCallback &#x3D; content; content &#x3D; title; &#125; ...&#125; 对于这种方式，我只想说：兄弟，简洁一点不好吗？]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 中的 number 为何很怪异]]></title>
    <url>%2Fjavascript%2F2%2F</url>
    
      <content type="text"><![CDATA[声明：需要读者对二进制有一定的了解 对于 JavaScript 开发者来说，或多或少都遇到过 js 在处理数字上的奇怪现象，比如： 1234567891011121314151617&gt; 0.1 + 0.20.30000000000000004&gt; 0.1 + 1 - 10.10000000000000009&gt; 0.1 * 0.20.020000000000000004&gt; Math.pow(2, 53)9007199254740992&gt; Math.pow(2, 53) + 19007199254740992&gt; Math.pow(2, 53) + 39007199254740996 如果想要弄明白为什么会出现这些奇怪现象，首先要弄清楚 _JavaScript 是怎样编码数字的_。 1. JavaScript 是怎样编码数字的JavaScript 中的数字，不管是整数、小数、分数，还是正数、负数，全部是浮点数，都是用 8 个字节（64 位）来存储的。 一个数字（如 12、0.12、-999）在内存中占用 8 个字节（64 位），存储方式如下： 0 - 51：分数部分（52 位） 52 - 62：指数部分（11 位） 63：符号位（1 位：0 表示这个数是正数，1 表示这个数是负数） 符号位很好理解，用于指明是正数还是负数，且只有 1 位、两种情况（0 表示正数，1 表示负数）。 其他两部分是分数部分和指数部分，用于计算一个数的绝对值。 1.1 绝对值计算公式123451: abs &#x3D; 1.f * 2 ^ (e - 1023) 0 &lt; e &lt; 20472: abs &#x3D; 0.f * 2 ^ (e - 1022) e &#x3D; 0, f &gt; 03: abs &#x3D; 0 e &#x3D; 0, f &#x3D; 04: abs &#x3D; NaN e &#x3D; 2047, f &gt; 05: abs &#x3D; ∞ (infinity, 无穷大) e &#x3D; 2047, f &#x3D; 0 说明： 这个公式是二进制的算法公式，结果用 abs 表示，分数部分用 f 表示，指数部分用 e 表示 2 ^ (e - 1023) 表示 2 的 e - 1023 次方 因为分数部分占 52 位，所以 f 的取值范围为 00...00（中间省略 48 个 0） 到 11...11（中间省略 48 个 1） 因为指数部分占 11 位，所以 e 的取值范围为 0（00000000000） 到 2047（11111111111） 从上面的公式可以看出： 1 的存储方式：1.00 * 2 ^ (1023 - 1023)（f = 0000..., e = 1023，... 表示 48 个 0） 2 的存储方式：1.00 * 2 ^ (1024 - 1023)（f = 0000..., e = 1024，... 表示 48 个 0） 9 的存储方式：1.001 * 2 ^ (1026 - 1023)（f = 0010..., e = 1026，... 表示 48 个 0） 0.5 的存储方式：1.00 * 2 ^ (1022 - 1023)（f = 0000..., e = 1022，... 表示 48 个 0） 0.625 的存储方式：1.01 * 2 ^ (1022 - 1023)（f = 0100..., e = 1022，... 表示 48 个 0） 1.2 绝对值的取值范围与边界从上面的公式可以看出： 1.2.1 0 &lt; e &lt; 2047当 0 &lt; e &lt; 2047 时，取值范围为：f = 0, e = 1 到 f = 11...11, e = 2046（中间省略 48 个 1） 即：Math.pow(2, -1022) 到 ~= Math.pow(2, 1024) - 1（～= 表示约等于） 这当中，~= Math.pow(2, 1024) - 1 就是 Number.MAX_VALUE 的值，js 所能表示的最大数值。 1.2.2 e = 0, f &gt; 0当 e = 0, f &gt; 0 时，取值范围为：f = 00...01, e = 0（中间省略 48 个 0） 到 f = 11...11, e = 0（中间省略 48 个 1） 即：Math.pow(2, -1074) 到 ~= Math.pow(2, -1022)（～= 表示约等于） 这当中，Math.pow(2, -1074) 就是 Number.MIN_VALUE 的值，js 所能表示的最小数值（绝对值）。 1.2.3 e = 0, f = 0这只表示一个值 0，但加上符号位，所以有 +0 与 -0。 但在运算中： 12&gt; +0 &#x3D;&#x3D;&#x3D; -0true 1.2.4 e = 2047, f &gt; 0这只表示一种值 NaN。 但在运算中： 12345&gt; NaN &#x3D;&#x3D; NaNfalse&gt; NaN &#x3D;&#x3D;&#x3D; NaNfalse 1.2.5 e = 2047, f = 0这只表示一个值 ∞ (infinity, 无穷大)。 在运算中： 12345&gt; Infinity &#x3D;&#x3D;&#x3D; Infinitytrue&gt; -Infinity &#x3D;&#x3D;&#x3D; -Infinitytrue 1.3 绝对值的最大安全值从上面可以看出，8 个字节能存储的最大数值是 Number.MAX_VALUE 的值，也就是 ~= Math.pow(2, 1024) - 1。 但这个数值并不安全：从 1 到 Number.MAX_VALUE 中间的数字并不连续，而是离散的。 比如：Number.MAX_VALUE - 1, Number.MAX_VALUE - 2 等数值都无法用公式得出，就存储不了。 所以这里引出了最大安全值 Number.MAX_SAFE_INTEGER，也就是从 1 到 Number.MAX_SAFE_INTEGER 中间的数字都是连续的，处在这个范围内的数值计算都是安全的。 当 f = 11...11, e = 1075（中间省略 48 个 1）时，取得这个值 111...11（中间省略 48 个 1），即 Math.pow(2, 53) - 1。 大于 Number.MAX_SAFE_INTEGER：Math.pow(2, 53) - 1 的数值都是离散的。 比如：Math.pow(2, 53) + 1, Math.pow(2, 53) + 3 不能用公式得出，无法存储在内存中。 所以才会有文章开头的现象： 12345678&gt; Math.pow(2, 53)9007199254740992&gt; Math.pow(2, 53) + 19007199254740992&gt; Math.pow(2, 53) + 39007199254740996 因为 Math.pow(2, 53) + 1 不能用公式得出，就无法存储在内存中，所以只有取最靠近这个数的、能够用公式得出的其他数，Math.pow(2, 53)，然后存储在内存中，这就是失真，即不安全。 1.4 小数的存储方式与计算小数中，除了满足 m / (2 ^ n)（m, n 都是整数）的小数可以用完整的 2 进制表示之外，其他的都不能用完整的 2 进制表示，只能无限的逼近一个 2 进制小数。 （注：[2] 表示二进制，^ 表示 N 次方） 120.5 &#x3D; 1 &#x2F; 2 &#x3D; [2]0.10.875 &#x3D; 7 &#x2F; 8 &#x3D; 1 &#x2F; 2 + 1 &#x2F; 4 + 1 &#x2F; 8 &#x3D; [2]0.111 12345678910111213# 0.3 的逼近0.25 ([2]0.01) &lt; 0.3 &lt; 0.5 ([2]0.10)0.296875 ([2]0.0100110) &lt; 0.3 &lt; 0.3046875 ([2]0.0100111)0.2998046875 ([2]0.01001100110) &lt; 0.3 &lt; 0.30029296875 ([2]0.01001100111)... 根据公式计算，直到把分数部分的 52 位填满，然后取最靠近的数0.3 的存储方式：[2]0.010011001100110011001100110011001100110011001100110011(f &#x3D; 0011001100110011001100110011001100110011001100110011, e &#x3D; 1021) 从上面可以看出，小数中大部分都只是近似值，只有少部分是真实值，所以只有这少部分的值（满足 m / (2 ^ n) 的小数）可以直接比较大小，其他的都不能直接比较。 12345&gt; 0.5 + 0.125 &#x3D;&#x3D;&#x3D; 0.625true&gt; 0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3false 为了安全的比较两个小数，引入 Number.EPSILON [Math.pow(2, -52)] 来比较浮点数。 12&gt; Math.abs(0.1 + 0.2 - 0.3) &lt; Number.EPSILONtrue 1.5 小数最大保留位数js 从内存中读取一个数时，最大保留 17 位有效数字。 123&gt; 0.0100110011001100110011001100110011001100110011001100110.300000000000000000.3 12&gt; 0.0100110011001100110011001100110011001100110011001100100.29999999999999993 12&gt; 0.0100110011001100110011001100110011001100110011001101000.30000000000000004 12&gt; 0.00000101000111101011100001010001111010111000010100011111000.020000000000000004 2. Number 对象中的常量2.1 Number.EPSILON表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值。 1Math.pow(2, -52) 用于浮点数之间安全的比较大小。 2.2 Number.MAX_SAFE_INTEGER绝对值的最大安全值。 1Math.pow(2, 53) - 1 2.3 Number.MAX_VALUEjs 所能表示的最大数值（8 个字节能存储的最大数值）。 1~&#x3D; Math.pow(2, 1024) - 1 2.4 Number.MIN_SAFE_INTEGER最小安全值（包括符号）。 1-(Math.pow(2, 53) - 1) 2.5 Number.MIN_VALUEjs 所能表示的最小数值（绝对值）。 1Math.pow(2, -1074) 2.6 Number.NEGATIVE_INFINITY负无穷大。 1-Infinity 2.7 Number.POSITIVE_INFINITY正无穷大。 1+Infinity 2.8 Number.NaN非数字。 3. 寻找奇怪现象的原因3.1 为什么 0.1 + 0.2 结果是 0.30000000000000004与 0.3 的逼近算法类似。 12345670.1 的存储方式：[2]0.00011001100110011001100110011001100110011001100110011010(f &#x3D; 1001100110011001100110011001100110011001100110011010, e &#x3D; 1019)0.2 的存储方式：[2]0.0011001100110011001100110011001100110011001100110011010(f &#x3D; 1001100110011001100110011001100110011001100110011010, e &#x3D; 1020) 1230.1 + 0.2: 0.0100110011001100110011001100110011001100110011001100111(f &#x3D; 00110011001100110011001100110011001100110011001100111, e &#x3D; 1021) 但 f = 00110011001100110011001100110011001100110011001100111 有 53 位，超过了正常的 52 位，无法存储，所以取最近的数： 1230.1 + 0.2: 0.010011001100110011001100110011001100110011001100110100(f &#x3D; 0011001100110011001100110011001100110011001100110100, e &#x3D; 1021) js 读取这个数字为 0.30000000000000004 3.2 为什么 Math.pow(2, 53) + 1 结果是 Math.pow(2, 53)因为 Math.pow(2, 53) + 1 不能用公式得出，无法存储在内存中，所以只有取最靠近这个数的、能够用公式得出的其他数。 比这个数小的、最靠近的数： 123Math.pow(2, 53)(f &#x3D; 0000000000000000000000000000000000000000000000000000, e &#x3D; 1076) 比这个数大的、最靠近的数： 123Math.pow(2, 53) + 2(f &#x3D; 0000000000000000000000000000000000000000000000000001, e &#x3D; 1076) 取第一个数：Math.pow(2, 53)。 所以： 12&gt; Math.pow(2, 53) + 1 &#x3D;&#x3D;&#x3D; Math.pow(2, 53)true 参考文章 How numbers are encoded in JavaScript JavaScript 是怎样编码数字的]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 中一些意想不到的使用技巧（持续更新，欢迎补充）]]></title>
    <url>%2Fjavascript%2F1%2F</url>
    
      <content type="text"><![CDATA[1. 箭头函数 =&gt; 返回 map 对象1234567&#x2F;&#x2F; 一般的写法const makeMap &#x3D; () &#x3D;&gt; &#123; return &#123;key: &#39;value&#39;&#125;;&#125;;&#x2F;&#x2F; 简洁的写法const makeMap &#x3D; () &#x3D;&gt; (&#123;key: &#39;value&#39;&#125;); 2. 对象属性名不确定，需要动态的传入123456789&#x2F;&#x2F; 一般的写法const makeMap &#x3D; (key, value) &#x3D;&gt; &#123; const obj &#x3D; &#123;&#125;; obj[key] &#x3D; value; return obj;&#125;;&#x2F;&#x2F; 简洁的写法const makeMap &#x3D; (key, value) &#x3D;&gt; (&#123;[key]: value&#125;); 3. 复制一个对象，并重写其中的一些属性12345678const source &#x3D; &#123;hello: &#39;hello&#39;, hi: &#39;hi&#39;&#125;;&#x2F;&#x2F; 一般的写法const target &#x3D; Object.assign(&#123;&#125;, source);target.hello &#x3D; &#39;hello everyone&#39;;&#x2F;&#x2F; 简洁的写法const target &#x3D; &#123;...source, hello: &#39;hello everyone&#39;&#125;; 4. 数组解构为函数参数12345678const arr &#x3D; [1, 2, 3];const plus &#x3D; (...args) &#x3D;&gt; args.reduce((a, b) &#x3D;&gt; a + b);&#x2F;&#x2F; 一般的写法plus(arr[0], arr[1], arr[2], 4, 5);&#x2F;&#x2F; 简洁的写法plus(...arr, 4, 5); 5. 向一个数组添加另一数组的所有元素12345678const arr1 &#x3D; [1, 2, 3];const arr2 &#x3D; [4, 5, 6];&#x2F;&#x2F; 一般的写法arr1 &#x3D; arr1.concat(arr2);&#x2F;&#x2F; 简洁的写法arr1.push(...arr2); 6. 回调函数简写1234567&#x2F;&#x2F; 一般的写法promise.catch(e &#x3D;&gt; &#123; console.log(e);&#125;);&#x2F;&#x2F; 简洁的写法promise.catch(console.log); 7. 多级箭头函数 =&gt;123456789&#x2F;&#x2F; 一般的写法const makeTimesFunc &#x3D; times &#x3D;&gt; &#123; return value &#x3D;&gt; &#123; return value * times; &#125;;&#125;;&#x2F;&#x2F; 简洁的写法const makeTimesFunc &#x3D; times &#x3D;&gt; value &#x3D;&gt; value * times; 8. 从右向左函数复式调用12345678910111213141516 &#x2F;&#x2F; 不确定元素个数，举例 3 个const fnCollection &#x3D; [str &#x3D;&gt; &#96;$&#123;str&#125; | fisrt&#96;, str &#x3D;&gt; &#96;$&#123;str&#125; | second&#96;, str &#x3D;&gt; &#96;$&#123;str&#125; | third&#96;];&#x2F;&#x2F; 一般的写法const addManySuffixes &#x3D; str &#x3D;&gt; &#123; let result &#x3D; str; for(let i &#x3D; fnCollection.length - 1; i &gt; -1; i -&#x3D; 1) result &#x3D; fnCollection[i](result); return result;&#125;;&#x2F;&#x2F; 简洁的写法const addManySuffixes &#x3D; fnCollection.reduce((a, b) &#x3D;&gt; str &#x3D;&gt; a(b(str)));&#x2F;&#x2F; 可以把 str 参数扩展成任意参数const addManySuffixes &#x3D; fnCollection.reduce((a, b) &#x3D;&gt; (...args) &#x3D;&gt; a(b(...args))); 后续更多博客，查看 https://github.com/senntyou/blogs 作者：深予之 (@senntyou) 版权声明：自由转载-非商用-非衍生-保持署名（创意共享 3.0 许可证）]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的最佳实践]]></title>
    <url>%2Fgit-tips%2F</url>
    
      <content type="text"><![CDATA[git 常用操作总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 克隆项目git clone https://github.com/majinhui04/sharegood-utils [本地文件夹]# 获取远程仓库的新分支以及删除远程仓库已删除的分支git fetch -p# 查看本地所有的分支git branch # 查看所有远程的分支git branch -r # → 查看所有远程分支和本地分支git branch -a # → 删除本地branchname分git branch -d &lt;branchname&gt; # → 创建新的分支并切换到该分支git checkout -b &lt;branchname&gt; # → 删除远程branchname分支git push origin -d &lt;branchname&gt; # 添加到暂存区去(提交当前目录或者它后代目录下相应文件)$ git add . # → 提交文件 -m 后面的是注释git commit -m 'feat: 新增了readme.md' # → 把当前的工作隐藏起来 等以后恢复现场后继续工作git stash # → 恢复工作现场（恢复隐藏的文件，同时删除stash列表中对应的内容）git stash pop # → 在本地（当前）分支上合并远程分支git merge origin/master # → 将本地master分支推送到远程origin主机的master分支git push origin master# → 查看package.json文件的commit记录git log package.json # → 精简模式查看提交的历史记录（只显示哈希值和提交说明） q 退出git log --pretty=oneline # → 回滚到指定版本，同时清空工作目录的所有改动git reset --hard HEAD # → 删除在远程已被删除的本地分支 (慎用)git branch -r | awk '&#123;print $1&#125;' | egrep -v -f /dev/fd/0 &lt;(git branch -vv | grep origin) | awk '&#123;print $1&#125;' | xargs git branch -d # → 删除了那些远程仓库不存在的分支 === git fetch -pgit remote prune origin # → 查看和编辑git的配置git config --list # → 忽略冲突，强制提交（慎用👎）git push origin &lt;brancename&gt; -f # → 列出所有&lt;code&gt;tag&lt;/code&gt;git tag # → 创建带有信息的git tag -a 'v1.0.0' -m 'first version' git中‘~’和‘^’的区别12345(&lt;commit&gt;|HEAD)^n，指的是HEAD的第n个父提交，可以通过在“^”后面跟上一个数字，表示第几个父提交，“^”相当“^1”。例如：HEAD^2 表示HEAD的第二次父提交。(&lt;commit&gt;|HEAD)~n，指的是HEAD的第n个祖先提交，可以通过在“~”后面跟上一个数字，表示第几个祖父提交，“~”相当“~1”，“~n”相当于连续的&lt;n&gt;个“^”。例如：HEAD~2 表示HEAD的第一个父提交的第一个父提交。等式1：HEAD~ === HEAD^ === HEAD^1 等式2：HEAD~2 === HEAD^^ === HEAD^1^1 配置123456789101112131415161718192021222324252627282930313233343536373839查看格式：git config [--local|--global|--system] -l$ git config --local -l # → 查看仓库级的config$ git config --global -l # → 查看全局级的config 编辑格式：git config [--local|--global|--system] -e$ git config --local -e # → 编辑仓库级的config$ git config --global -e # → 编辑全局级的config 修改格式：git config [--local|--global|--system] section.key value$ git config --local push.default 'simple' # → 修改仓库级的push.default的默认行为$ git config --global push.default 'current' # → 修改全局级的push.default的默认行为 * 关于git default配置这里增加格式: git config [--local|--global|--system] --add section.key value(默认是添加在local配置中)$ git config --add cat.name songhw # → local配置写入 cat.name = songhw$ git config --local --add cat.name songhw # → 等同于上一步$ git config --global --add cat.name lhammer # → global配置写入 cat.name = lhammer 获取格式：git config [--local|--global|--system] --get section.key(默认是获取local配置中内容)$ git config --get cat.name # → 输出songhw$ git config --local --get cat.name # → 输出结果同上一步$ git config --global --get cat.name # → 输出lhammer 删除格式：git config [--local|--global|--system] --unset section.key$ git config --local --unset cat.name # → 删除local配置中的cat.name = songhw$ git config --global --unset cat.name # → 删除local配置中的cat.name = lhammer]]></content>
    
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>团队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一题：如何处理Promise并发限流]]></title>
    <url>%2FPromise-map%2F</url>
    
      <content type="text"><![CDATA[提问大家应该都经历过这么一个场景，当我们使用微博或者写文章的时候，网站允许我们一次性选择多个图片进行上传，或者当我们写爬虫的时候都需要用并发来提高效率，那么问题来了，因为并发数过大会影响服务器的性能，因此需要限流。那我们如何实现并发的同时又限制个数呢？请实现一个Promise.map方法 先思考一下下…….. 回答设计成 Bluebird（npm包） 的 API，是比较模块化，也是易于使用的。代码的关键在于维护一个队列，当超过限定数量的 Promise 时，则交与队列维护。代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Limit &#123; constructor (n) &#123; this.limit = n this.count = 0 this.queue = [] &#125; enqueue (fn) &#123; // 关键代码: fn, resolve, reject 统一管理 return new Promise((resolve, reject) =&gt; &#123; this.queue.push(&#123; fn, resolve, reject &#125;) &#125;) &#125; dequeue () &#123; if (this.count &lt; this.limit &amp;&amp; this.queue.length) &#123; // 等到 Promise 计数器小于阈值时，则出队执行 const &#123; fn, resolve, reject &#125; = this.queue.shift() this.run(fn).then(resolve).catch(reject) &#125; &#125; // async/await 简化错误处理 async run (fn) &#123; this.count++ // 维护一个计数器 const value = await fn() this.count-- // 执行完，看看队列有东西没 this.dequeue() return value &#125; build (fn) &#123; if (this.count &lt; this.limit) &#123; // 如果没有到达阈值，直接执行 return this.run(fn) &#125; else &#123; // 如果超出阈值，则先扔到队列中，等待有空闲时执行 return this.enqueue(fn) &#125; &#125;&#125;// concurrency 并发数目Promise.map = function (list, fn, &#123; concurrency &#125;) &#123; const limit = new Limit(concurrency) return Promise.all(list.map((...args) =&gt; &#123; return limit.build(() =&gt; fn(...args)) &#125;))&#125; 课外题：自己实现一个Promise.all函数]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020史上最全的web前端资源整合]]></title>
    <url>%2Fweb-frontend-resource%2F</url>
    
      <content type="text"><![CDATA[vue.js高仿饿了么（1-13章全）链接：https://pan.baidu.com/s/1qYSiYXluA1AlEV0EskxWZw提取码：25z9 Vue.js 2.5 + cube-ui 重构饿了么 App链接：https://pan.baidu.com/s/1UZyLkzYMvhUhhX3GH5ITvA提取码：bx53 Vue2.0 + Node.js + MongoDB全栈打造商城系统链接：https://pan.baidu.com/s/10Jm22uzp4p2NMMRlNac7Rg提取码：uns3 Vue 2.0 高级实战-开发移动端音乐 WebApp链接：https://pan.baidu.com/s/1RvF1KziTgq4HEaIVnCvz1w提取码：v0vb vue去哪儿无密APP链接：https://pan.baidu.com/s/1vQMWuSNJJ8OrxoGVcZTgtw提取码：u3yz Vue全家桶+SSR+Koa2全栈开发美团网链接：https://pan.baidu.com/s/1KTzsYSB5-Ua47r-jArSgJw提取码：qwen 7天搞定Node.js微信公众号开发链接：https://pan.baidu.com/s/1Aw6be7tp8ysDs0N1H7Kf_Q提取码：gf6q Vue + Node + MongoDB高级全栈链接：https://pan.baidu.com/s/1dK5XH_Uxi21dZTYwGR-KkQ提取码：ta3s VUE核心技术视频链接：https://pan.baidu.com/s/1hYxRi5nw82Au9AKdvo4RhQ提取码：aooh Vue核心技术 Vue+Vue-Router+Vuex+SSR实战精讲链接：https://pan.baidu.com/s/1TKaSoWhLfxdHZifYMwPbzw提取码：rbcy Vue2.x实战项目(axios路由vuex)链接：https://pan.baidu.com/s/1YPYORI7SnHgGo5Gq7zzGsA提取码：so0h MUI 仿豆瓣电影 APP跨平台混编框架链接：https://pan.baidu.com/s/1CErOI6eWLEhf3qJeSALAng提取码：59qs webApp书城整站开发链接：https://pan.baidu.com/s/1nA7CXe_1IYnmQibK3-ETig提取码：orul Koa2框架从0开始构建预告片网站链接：https://pan.baidu.com/s/1UiwmhLnX1XOCLCAg_rLJwA提取码：l0kj 响应式网页制作实战项目链接：https://pan.baidu.com/s/1pHEe8p0b3f-JbQ7A0D1Xhw提取码：7lon Ionic2飞速上手的跨平台App开发链接：https://pan.baidu.com/s/1y3psOTyHez06Xfe9Jb-tWw提取码：0eje 快速上手Ionic3 多平台开发企业级问答社区链接：https://pan.baidu.com/s/1OJhxoef5v6BL9W6MnjNZ3Q提取码：souy Webpack + React全栈工程架构项目实战精讲链接：https://pan.baidu.com/s/1gUDZ5sDBIGNa_jnJnioWgQ提取码：t4zq Redux + react + Router + Node.js全栈开发链接：https://pan.baidu.com/s/1aDUmEJIt3USjxwVQrT-Mkg提取码：olfg React16 + React-Router4 从零打造企业级电商后台管理系统链接：https://pan.baidu.com/s/1Hlykhdh0Nm02SMj1NxDqbw提取码：m47b React.js入门与实战[开发适配PC端及移动端新闻头条平台]链接：https://pan.baidu.com/s/1GrBYd69i7LmiD6ONIT9zGw提取码：vcjb React 高级实战 打造大众点评 WebApp链接：https://pan.baidu.com/s/10aUtKTFc2lA2uLrqCOsv3Q提取码：f6am React Native开发App狗狗说链接：https://pan.baidu.com/s/1uZBZsviDWJOAMrb98GDijQ提取码：gmtt 掌握React Native技术转型随意切换链接：https://pan.baidu.com/s/1OLf5EHEeCvTkqBbxft_jsA提取码：hjji ReactJS链接：https://pan.baidu.com/s/1dNf4fNWLyZ8kTwsOne564Q提取码：hd6o 实战 贯穿全栈React Native开发App链接：https://pan.baidu.com/s/13spZQ3nGBZiiT9dsakEY0g提取码：7jqz 东方要React-native全教程链接：https://pan.baidu.com/s/1k7D5QHrJAae3SyV7fgH_Pg提取码：zzpb React 框架课程套装链接：https://pan.baidu.com/s/1NfYV4qfKdi95GbebH-PNaA提取码：s9uv React 高级实战大众点评链接：https://pan.baidu.com/s/1vrItn64u49mwXMkG0foItg提取码：ceoz React Native 快速开发App一步到位链接：https://pan.baidu.com/s/1vIaYd68hPC6WZTTGEuLFog提取码：jtr9 彻底征服 React.js链接：https://pan.baidu.com/s/1XwzTYO8U3Z9mN6PIP4gafQ提取码：4sp3 React.js es6包含实战链接：https://pan.baidu.com/s/1l4jh_kIOsXEKSaIo4fUzIA提取码：gdp6 React+Redux+react-router链接：https://pan.baidu.com/s/1xNPe582fJsMoVObw5_O5Bw提取码：yr94 React Native小码哥电商链接：https://pan.baidu.com/s/1ev6I-2qkFZry0ar_LnaZ4A提取码：96dw React Native快速开发-厕所在哪App链接：https://pan.baidu.com/s/1cKSNHhNkK0mC6bUOHaIPsg提取码：u5cl React 苹果官网产品展示效果+源码等多个文件链接：https://pan.baidu.com/s/1bPfUcAHH0g8eLFIDqtBNpQ提取码：54o2 Angular JS 仿拉勾网 WebApp链接：https://pan.baidu.com/s/1EaEdEkFZMLvI3NNPYodc5A提取码：5tkc Angular 打造企业级协作平台链接：https://pan.baidu.com/s/1vEsBm8drlsyYI3vYVT1m7A提取码：vysn Angular 4.0从入门到实战 打造股票管理网站链接：https://pan.baidu.com/s/1CKOtDYw25maVbkYDh84qig提取码：kodf AngularJS全栈开发知乎链接：https://pan.baidu.com/s/1wUHp0kF1wcDBNpH4qUOJrg提取码：bbi6 AngularJS链接：https://pan.baidu.com/s/17cLzs-AkNAqD8eLR9hmeOg提取码：qyxa Angular4 视频教程-it营（大地）链接：https://pan.baidu.com/s/1NiwYVNiQORp9s1IPlK8lZw提取码：kxz5 手把手从0打造电商平台链接：https://pan.baidu.com/s/1o81d8TozMI72MX_IIRCD9w提取码：bq1y ES6+ 开发电商网站的账号体系 JS SDK链接：https://pan.baidu.com/s/19Tqk4ERUM7m3PdhGDAss7A提取码：12dk ES6零基础教学 解析彩票项目链接：https://pan.baidu.com/s/1A7gSrfadxw88lVwiP98Skg提取码：cdd7 Node.js入门到企业Web开发中的应用链接：https://pan.baidu.com/s/1Qt252KSqSAIJi-EmKib4PQ提取码：qnrd 四大维度解锁 Webpack 3.0 前端工程化链接：https://pan.baidu.com/s/1hXgm27tTZoRBN8HCE7W0Hw提取码：85yw 6小时 jQuery开发一个前端应用链接：https://pan.baidu.com/s/1hwO36zQKZp1gKx6mHxKQ_w提取码：hnao HTTP协议原理+实践 Web开发工程师必学链接：https://pan.baidu.com/s/1isAvkjKOMLsWGGNckOXsPw提取码：mk98 微信小程序入门与实战链接：https://pan.baidu.com/s/1EGZ8QG9MJJjJ_3wTu3Wmeg提取码：rme0 全新升级 Kotlin系统入门与进阶链接：https://pan.baidu.com/s/1WF6ORDNrg4Mel4HllX0zTg提取码：h4mn Kotlin打造完整电商APP 模块化 + MVP + 主流框架链接：https://pan.baidu.com/s/1CW-EV7HU70btAOs_v0uMVQ提取码：nrht]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之简历篇]]></title>
    <url>%2Fresume%2F</url>
    
      <content type="text"><![CDATA[1.前期准备 投其所好 一般公司招聘都会有一些硬性要求，比如工作经历、学历、技术栈、岗位要求等等。因此应聘之前，一方面，要花时间将自己力所能及的盲点覆盖到，一方面，找对合适的公司进行投递。盲目的海投只会让简历石沉大海。也会打击你的信心。 下面从网上整理了两份的不同级别招聘需求，供大家参考中级前端工程师 123456789101112131415岗位职责：1、负责WEB端开发工作，与后端工程师配合，为项目提供最优化的技术解决方案；2、开发前端代码，实现产品的页面交互和数据逻辑展示；3、与产品讨论确定，并实现良好体验的交互效果4、解决兼容性问题，优化前端性能，改善用户体验；5、统一可重用组件，规范前端模块化开发。任职要求：1. 一年及以上相关工作经验2. 熟练使用HTML，CSS，Javascript等前端技术，熟练处理浏览器兼容问题；3. 熟悉react、vue、Angular等至少一种框架，有实际项目经验，能独立开发高质量组件，能够封装一些常用的函数类库4. 熟练使用Webpack，Gulp等前端构建工具5. 代码编写规范，熟悉W3C标准，熟悉前端性能优化并能熟练运用；6. 有较强的团队合作能力与独立解决技术问题的能力。7. 熟练使用git或者svn版本管理工具；8. 加分项：有优秀的开源作品，优秀技术博客（如果有，请贴上地址，如github，npm等地址） 高级前端工程师 1234567891011岗位职责： 1. 构建可视化研发平台，优化前端开发方式及协作流程，创建技术标准及规范，用智能化方式提高前端研发效能，逐步实现‘无代码研发’2. 抽象业务问题，管控业务需求，主导平台型业务的技术架构设计，推动数据化运营模式升级3. 为组员的技术成长制定目标、计划并帮助实施，提升整体技术水平岗位要求： 1. 精通各种Web前端技术（HTML&#x2F;CSS&#x2F;Javascript等)，熟悉网络协议（HTTP&#x2F;SSL），熟悉常见安全问题和对策2. 精通Babel&#x2F;Webpack，对AST有深度理解3. 熟悉BaaS&#x2F;FaaS，对serverless有深刻理解4. 对前端事件流、数据流有深度理解，具备抽象视图层与数据层交互协议的能力，有复杂可视化搭建平台的研发经验优先5. 具备跨端研发能力，有前端渲染容器实现和沙箱隔离相关实践经验6. 个性乐观开朗，逻辑性强，善于和各种背景的人合作，有丰富的项目管理、团队管理经验。 2.关于内容 突出重点 一般前端简历包括以下的几个部分： 12345基础信息职业技能工作经历项目经验自我评价(选填，别超过120字) 很多同学都一上来就是一片洋洋洒洒的论文。只要会一点的知识点、专业术语都恨不得都往上搬，显得很饱满。注意，简历不是论文，没有字数要求。 要突出重点，对自己擅长的领域着重描述一下。这几块里面，其中面试官一般最关注是项目经验，所以大家要花点心思在这里进行一番“吹逼”。 关于格式投递简历的时候一定要word 或者 pdf格式的，有些同学喜欢制作网页版简历，虽然看着比较酷炫，但是初次筛选的都是HR，并不会看源码，整理起来也比较麻烦。所以word 和 pdf 格式的载体足够了，多花精力放在简历内容上。 基础信息1234567姓名、性别、年纪、手机、邮箱工作经验、应聘职位、期望待遇（选填）博客地址（选填）、GitHub 地址（选填，没作品不填）学校（选填）学历专业 职业技能这一块基本千篇一律，为什么会这样呢，因为大家都习惯性的把前端相关技术的都罗列了一遍。没有重点。 反面教材： 12345678910111213141516171、熟练使用HTML&#x2F;HTML5、CSS&#x2F;CSS3、js进行合理的PC端和移动端网页布局与交互；2、熟悉web客户端各主流浏览器之间的兼容性，熟悉响应式布局；3、掌握JavaScript、DOM等前端技术；4、熟练运用 ajax，jsonp 技术与后台处理数据，熟悉浏览器跟服务器交互机制； 5、熟悉 webpack自动化构建工具；6、熟练使用 sass、less、stylus预处理器执行编译 css； 7、熟练使用jQuery、MUI等框架；8、熟练使用bootstrap、swiper等辅助工具； 9、熟练使用vue、vue-cli，能基于 vue（2.0）使用 mintUI 以及 ElementUI 开发项目；10、熟练微信小程序开发，支付宝小程序开发；11、了解PHP等后台编程语言，有前后端分离开发经验；12、了解MySQL数据库使用、对前后端合作开发有一定的认知；13、可以熟练使用Git、SVN进行项目管理。14、使用HBuilder进行软件的打包发布、配置权限15、对svg、canvas有一定了解；16、了解界面UI设计、页面架构与布局，具备良好的用户体验意识；17、了解部分图形图像软件（如Photoshop），对从设计转换为产品有一定的认识，可以进行简单的切图操作。 一般情况下面试官都会自动无视了解(除非是应届生)，所以不如花更多的精力在熟悉和精通上面 正面教材： 12345678910&#x2F;&#x2F; 1、2、3熟练使用各种 web 前端技术,包括 HTML(5)&#x2F;CSS(3)&#x2F;JS 等,能快速还原 PSD 源文件,解决各类浏览器兼容性。&#x2F;&#x2F; 7、8、9熟练使用 vue 框架快速的构建项目,以及第三方库(mintUI、ElementUI、bootstrap、jQuery、MUI)&#x2F;&#x2F; 5、6熟悉webpack自动化构建工具，熟练使用 sass、less、stylus预处理器&#x2F;&#x2F; 10熟练微信小程序开发，支付宝小程序开发&#x2F;&#x2F; 13熟练使用Git、SVN进行项目管理，制作过一个版本管理工具(https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx) 前端技术现在有NodeJS、H5、Hybrid、架构和业务研发等方向，不要什么都全栈不易，尽量将内容聚焦于自己最擅长的领域，扬长避短，以此来引导面试官来问你擅长的部分。 不关注：证书、四六级、了解的编程语言（如果不精通就不要写）、自我评价。 工作经历不要出现和前端不相关的工作经历。内容包含：公司、工作时间、工作职位、工作内容、公司介绍（选填，公司性质、规模、行业，不要出现大段描述） 123456789101112XXX公司 2019.01.01~2020.01.01 前端负责人工作内容1. 招聘，培养新人2. 制定前端规范3. 任务管理，团队管理4. 前端WIKI维护5. 混合开发框架优化6. 金融APP开发7. 相关管理端开发8. 协助组员解决各类问题9. 支撑产品，评审产品可行性10. 支撑后端，解答前端相关问题 项目经验 千万不要把所有的项目罗列一遍，一般不同类型的三个项目足够了，要经得起推敲，表现出亮点。 现在招一个能干活的人不难，难的是招一个能解决问题的。是不是能够分辨真实需求，合理制定技术方案，推动项目进度，产出结果，复盘问题很重要。所以，应对这每个环节所需的技能，最好在简历里有所表现。具体说就是描述每个项目时，不仅要有背景、过程，还要有你为这个项目带来的结果。 一般项目基本都会包含组件、UI交互、脚手架、业务模块、沟通协作。如果是组件，要知道设计思路。如果是UI交互，要说明这样的交互体验更好的原因。如果是脚手架，讲原理和适用场景。如果是业务模块，讲一下难点和核心代码。如果是沟通协作，讲一下方式方法。 反面教材1：谁也不知道你都做了什么，用什么做的，结果如何，完成得怎么样，没有看到具体成果 反面教材2： 12345BI后台系统项目介绍:使用vue-cli+element来构建BI后台,并通过axios来请求数据。主要职责: 独立研发BI系统,通过系统来请求后台的模板、工作表、数据转换的数据请求以及用 vue 的 echart 插件和组件功能来显示图表插件并能动态编辑图表数据。 有结果，但是看不出解决了什么问题，没有可量化的指标，没法凸显你的价值 正面教材： 1234567891011121314BI后台系统项目介绍: 提供商品&amp;品牌等各项指标报表，运营活动转化率，用户画像采集等数据可视化功能，实现智能化运营项目职责:1.独立构建SPA脚手架，支持不同环境加载不同CDN资源2.项目支持PC端和IPAD端的自适应布局，完成统一的RESTFUL的标准化接口3.进行二次业务组件，将常规的查询、自定义表单等封装成公共组件4.完成动态编辑图表等五个模块，支持PDF下载项目业绩: 1.通过vue-cli3进行了打包依赖优化，节省了大概20%的编译时间。2.利用elementUI封装的业务组件不仅统一了各个业务模块的UI交互，而且减少了30%的开发时间。大大减低了研发成本。3.通过使用YAPI以及自定义数据mock方案，克服了项目开发前期的数据联调困难，极大得提高了开发效率。4.基于echart完成的动态报表组件，实现了不同的报表需求随时动态编辑，快速上线，不再需要每次重新开发和发版。5.最终基于这个项目整理出了标准化的后台模板，并在其他业务线进行了推广。 不要堆砌一大堆的专业名称，HR表示看不懂，尽量把成果具体化，数字化 请遵循STAR法则Situation（情景）: 工作背景是什么Task（任务）我负责做什么Action（行动）: 我做了什么Result（结果）: 结果怎么样(最好可以量化) 3.典型问题 谦虚谨慎 此外面试中还会问 1231. 哪个项目让你最满意、代表你的最高水平？如何做的？2. 让你印象最深刻的一个（技术）难点，害的你搞了很久，最后怎么解的，有什么心得？3. 你能给我们团队或者产品带来什么？ 这些问题不是硬性的，主要看平时是不是除了技术还琢磨点别的，特别是产品基本形态成型的基础上，你如何试错、创新、提效、求精、找方向，这种情况下，只具备技术能力已经远不够了，而更需要辩证的执行。 4.总结最后，简历一定要实事求是，千万不能弄虚作假，这不仅关系到对你专业能力的评估，更是对人品的考验，即便能力再强，被发现后，不仅可能丢掉到手的offer，甚至臭名远扬。 ps: 如果有简历和面试相关的疑惑可以联系我：QQ 504397517]]></content>
    
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端资源分享]]></title>
    <url>%2Ffront-end-resources%2F</url>
    
      <content type="text"><![CDATA[front-end-resources一、团队组织 网站 说明 腾讯 AlloyTeam 团队 腾讯Web前端团队，代表作品WebQQ，致力于前端技术的研究 ISUX 腾讯社交用户体验设计，简称ISUX，腾讯设计团队网站 CDC 腾讯用户研究与体验设计部 FEX 百度Web前端研发部出品 淘宝前端团队（FED） 用技术为体验提供无限可能 凹凸实验室 京东用户体验设计部出品 奇舞团 奇虎360旗下前端开发团队出品 阿里巴巴国际UED团队 在更新的屏幕里创造出更好的产品和更优的体验 EFE 由百度多个遵循统一技术体系的前端团队所组成 UXC 覆盖了百度85%以上的产品体验设计 二、开发社区 网站 说明 StackOverflow 加入世界上最大的开发者社区 SegmentFault 中文领域最大的技术问答交流社区平台 知乎 中文互联网最大的知识分享和社交平台 开源中国 目前国内最大的开源技术社区 w3ctech 中国最大的前端技术社区 掘金 一个帮助开发者成长的社区 V2EX 创意工作者们的社区 博客园 一个面向开发者的知识分享社区 CNode 国内最大最具影响力的 Node.js 开源技术社区 Ruby China 由众多爱好者共同维护的 Ruby 中文社区 三、前端门户 网站 说明 前端网 一个专注于Web前端开发行业的综合性门户网站 大前端 一个集前端开发和Wordpress内容为一体的双轨独立网站 四、前端大牛 网站 说明 AlloyTeam 腾讯Web前端团队 taobaofed 淘宝前端团队（FED） alinode团队博客 基于 Node 运行时的应用性能管理解决方案 鑫空间-鑫生活 张鑫旭,上海阅文信息技术有限公司用户体验设计师 廖雪峰的官方网站 廖雪峰，著有《Spring 2.0核心技术与最佳实践》一书。 阮一峰的个人网站 阮一峰,2014年出版《ECMAScript 6入门》 JavaScript 秘密花园 三生石上 囧克斯 勾三股四 w3cplus 大漠，就职淘宝，CSS3、CSS处理器和Drupal中国布道者。2014年出版《图解CSS3：核心技术与案例实战》。 酷 壳 – COOLSHELL 陈皓，就职经历Amazon中国任研发经理；阿里北京研发中心、商家业务部资深专家；阿里核心系统和阿里云ECS相关的虚拟化平台的开发工作。 html5ify 朴灵，阿里数据产品部资深工程师。致力前端、数据可视化、Node等领域 Ruby’s Louvre 钟钦成,网名司徒正美,著名的JavaScript专家,去哪儿网前端架构师 CSS森林 GhostZhang,微信支付设计中心，负责重构前端团队的管理工作。 99css ytzong,就职经历139 邮箱前端工程师；腾讯 ISUX 前端工程师； iOS 独立开发者 [米随随] s5s5 刘小超，现在就职于 Tencent ISUX ，岗位 UI Engineer，主要从事UI开发方面工作。 小胡子哥的个人网站 Barret李靖，阿里巴巴职员 Jerry Qu 屈光宇，奇虎 360，前端开发 EVILCOS 余弦，知道创宇 WEB前端开发 愚人码头，内容涵盖Web前端开发原创教程、技术中文文档、前端工具、资源分享、疑难解答、最新技术、招聘信息等 伯乐在线 黄余粮，黄利民 Aimingoo’s Blog 周爱民，一名程序员、架构师，就职物联网公司（ruff.io） justjavac(迷渡) justjavac，天津维基科技有限公司研发工程师 Be For Web C7210，交互设计师、UX热爱者、译者 Alon’s Blog Alon Zhang，互联网资讯博主 I’m qiqiboy! qiqiboy，wordpress开发、web前端 五、活跃微博 网站 说明 掘金技术社区 挖掘最优质的互联网技术 w3c中国 万维网联盟中国办事处官方微博 六、书籍推荐 书籍 作者 译者 《Web标准设计》 刘杰（嗷嗷） 《大巧不工 Web前端设计修炼之道》 赖定清 / 林坚 《高性能网站建设指南 前端工程师技能精髓》 Steve Souders 刘彦博 《高性能网站建设进阶指南 Web开发者性能优化最佳实践》 Steve Souders 口碑网前端团队 《Web站点优化》 金 《Node.js开发指南》 郭家寶（BYVoid） 《JavaScript高级程序设计（第3版）》 [美] 尼古拉斯·泽卡斯 李松峰 / 曹力 《JavaScript权威指南》 弗拉纳根 李强 《JavaScript语言精粹》 Douglas Crockford 赵泽欣/ 鄢学鹍 《深入浅出Node.js》 朴灵 《CSS开发王》 张亚飞 《JavaScript DOM编程艺术 （第2版）》 [英] Jeremy Keith / [加] Jeffrey Sambells 杨涛 / 王建桥 / 杨晓云 等 七、前端教程 网站 说明 W3C中国 Web技术领域最具权威和影响力的国际中立性技术标准机构 MDN Web 文档 学习 Web 开发的最佳实践 w3cschool 学编程，从w3cschool开始 Microsoft Web 开发 Developer Network 八、HTML(5) 网站 说明 HTML(超文本标记语言)MDN MDN Web 文档 后HTML5时代Ⅰ TGideas 万技师 后HTML5时代Ⅱ TGideas 鬼爪手 HTML5 进阶系列 爱前端 林鑫 匠心打造canvas签名组件 翟灿东，网名路易斯，平安健康前端工程师。 HTML5 有哪些让你惊艳的 demo？ 知乎 关注者 8K 一只会飞的鱼 每周一点canvas动画 九、CSS(3) 网站 说明 CSS Reference 从基础知识中学习CSS的所有重要属性 You Don’t Know CSS 杨健 强大的css3 Wayne Zhu 深入了解 CSS3 新特性 周 翔 Flex 布局教程：语法篇 阮一峰 Flex 布局教程：实例篇 阮一峰 如何编写轻量级 CSS 框架 叙帝利 CSS 专业技巧 一个帮你提升 CSS 技巧的收藏集 CSS3技术-雪碧图自适应缩放与精灵动画方案 慕课网 艾伦 Aaron 搞定这些疑难杂症，向css3动画说yes IMWeb 结一 Effective前端1：能使用html/css解决的问题就不要使用JS 会编程的银猪 前端如何呼风唤雨 IMWeb coverguo 默认的checkbox、input、radio太丑了？我来教你改变使用纯css3改写的带动画的默认样式 掘金 sunshine小小倩 CSS性能分析，如何优化CSS提高性能 博客园 楼兰小骑士 CSS 黑魔法小技巧，让你少写不必要的JS，代码更优雅 思否 微醺岁月 CSS-Tricks The Shapes of CSS 十、ECMAScript 网站 说明 Understanding ECMAScript 6 Nicholas C. Zakas 探索 ES6 翻译自《 Exploring ES6 》 ECMAScript 6 入门 阮一峰 ES5合集 颜海镜 ES6 你可能不知道的事 - 基础篇 化辰，淘宝前端团队（FED） ES6 你可能不知道的事 - 进阶篇 化辰，淘宝前端团队（FED） 十一、JavaScript 网站 说明 JavaScript 标准参考教程（alpha） 阮一峰 JavaScript 秘密花园 三生石上 中文翻译 JavaScript Promise迷你书（中文版） 原著：azu / 翻译：liubin、kaku、honnkyou JS 函数式编程指南 Linghao Li JavaScript 闯关记 stone0090 十二、jQuery 网站 说明 学习jQuery Learning Center jQuery API 中文文档 官方 jQuery API中文文档 愚人码头 jQuery UI API中文文档 愚人码头 jQuery中文手册 hemin YOU MIGHT NOT NEED JQUERY 你可能不需要JQUERY 十三、Vue.js 网站 说明 Vue.js 官方网站 vuejs 官方仓库 Vue 中文社区 全球最大的 Vueframework 中文开源技术社区 vuefe.cn Vue.js 中文文档 Vue Forum Vue 论坛 Vue Land Vue 聊天室 vue-devtools 用于调试Vue.js应用程序的浏览器devtools扩展 Vue Loader 一个 webpack 的 loader vue-router 官方路由 Vuex 状态管理模式 Vue 服务端渲染 Vue.js 服务器端渲染指南 Vue package Find the best packages for your Vue app! awesome-vue Awesome Vue.js Element 一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 iView 一套基于 Vue.js 的高质量 UI 组件库 Vue + webpack 项目实践 勾三股四 vue 性能优化 岛书,Coffcer 十四、AngularJS 网站 说明 Angular 中文版 官方网站 AngularJS入门教程 严清 , 李诗剑 (译者) AngularJS在线教程 乔乐共享 AngularJS学习笔记 邹业盛 Angularlearning Angular.js 的一些学习资源 UI Bootstrap Bootstrap components written in pureAngularJSby theAngularUI Team AngularStrap AngularJS 1.2+ native directives for Bootstrap 3 AngularLearning dolymood 十五、React 网站 说明 React 官方网站 React 中文索引 Made by 题叶 &amp; Feifei Hang React China React 中文的论坛 React 入门实例教程 阮一峰 React Router 使用教程 阮一峰 React Native 中文版 极客学院 React.JS教程 PHPERZ React.js 2016 最佳实践 腾讯全端 AlloyTeam 团队 Blog React 导读 小撸,国双科技 Redux 中文文档 收到 Redux 作者 Dan 的多次点赞 React Router 中文文档 官方文档中文翻译 React 介绍及实践教程 董越 和 徐新茹 React 设计思想 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写 React Webpack 小书 作者 Christian Alfoni and Juho Vepsäläinen 中文译者 Fakefish Material-UI React 前端 UI 库 Amaze UI React 基于 React.js 开发的 Web 组件库 dva 基于 redux、redux-saga 和 react-router 的轻量级前端框架 Ant Motion 能够快速在 React 框架中使用动画 十六、Node.js 网站 说明 NODESCHOOL 教你 Web 开发技能的开源课程，自学或者参加一个附近的教学活动 Node入门 作者： Manuel Kiessling 翻译： goddyzhao &amp; GrayZhang &amp; MondayChen 七天学会NodeJS Alibaba.com Node.js 包教不包会 alsotang 从零开始nodejs系列文章 粉丝日志 NodeJS的代码调试和性能调优 小胡子哥 Express 基于 Node.js 平台，快速、开放、极简的 web 开发框架 Express框架 阮一峰 Koa 框架 阮一峰 Koa Koajs 中文文档 十七、RequireJS 网站 说明 Javascript模块化编程 阮一峰 RequireJS学习 叶小钗 RequireJS入门 Snandy RequireJS 入门指南 参与翻译 NCThinker, 姜鹏飞, super0555 十八、Sass和Less 网站 说明 Sass中文网 世界上最成熟、最稳定、最强大的专业级CSS扩展语言 SASS中文文档 Sass 是成熟、稳定、强大的 CSS 扩展语言 SASS用法指南 阮一峰 Sass入门 大漠 Less中文文档 给 CSS 加点料 十九、Webpack 网站 说明 webpack 官方网站 webpack 中文 中文官网 webpack github webpack-demos 阮一峰 二十、Markdown 网站 说明 Markdown 语法说明 (简体中文版) riku Markdown 入门参考 LearnShare GitBook 帮助团队在线撰写，协作和发布内容 Cmd Markdown Cmd Markdown 编辑阅读器 StackEdit 浏览器中的Markdown编辑器 Mditor 一款轻量级的markdown编辑器 二十一、Git和GitHub 网站 说明 Git-Book 官方文档 git - 简明指南 罗杰·杜德勒 猴子都能懂得GIT入门 backlog 廖雪峰的官方网站 Git教程 廖雪峰 Learn Git Branching 通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能 Git工作流指南 李鼎(哲良),taobao 有关 git 的学习资料 xirong,alibaba GitHub 漫游指南 Phodal Huang,黄峰达,ThoughtWorks 高级咨询师 GitHub秘籍 Star 24.8k Fork 3.8k 二十二、Github大牛 网站 说明 AlloyTeam 腾讯 AlloyTeam fex-team Baidu FEX team tmallfe 天猫前端团队 nzakas 尼古拉斯·泽卡斯 Nicholas C. Zakas，雅虎首页的前端技术主管， YUI 库的贡献者，目前在 Box 公司任职 tj TJ Holowaychuk，Koa、Co、Express、jade、mocha、node-canvas、commander.js等知名开源项目的创建和贡献者 JacksonTian 朴灵(田永强)，就职阿里巴巴数据平台，Node.js布道者 lifesinger 玉伯，支付宝前端，seajs作者 jobbole 伯乐在线 paulirish Google Chrome kejun Douban Inc fengmk2 fengmk2，Alipay fool2fish Zhouxuan Yang，Alipay jayli Taobao 二十三、框架类库 网站 说明 WeUI 微信官方设计团队为微信 Web 开发量身设计 ZUI 一个基于 Bootstrap 深度定制开源前端实践方案，帮助你快速构建现代跨屏应用。 MZUI 为移动端设计，基于 Flex 的 UI 框架 SUI Mobile 阿里他她，一套基于 Framework7 开发的UI库 KISSY 一款跨终端、模块化、高性能、使用简单的 JavaScript 框架 nice validator 领先的表单验证解决方案 Underscore.js 一整套函数式编程的实用功能 Lodash 通过解决数组，数字，对象，字符串等问题，让JavaScript变得更轻松。 Metro UI CSS 一个 BizSpark Startup Kite CSS 一个灵活的布局助手 Creative Link Effects 创意链接或菜单项效果 JAVASCRIPTING 最优的javascript库、框架和插件。 Microjs 神奇的微型框架 二十四、动画 网站 说明 Animate.css 一个跨浏览器的CSS动画库 Bounce.js 触摸库 CSS3关键帧动画 Waves.js 点击按钮或背景动画 缓动函数 指定动画效果在执行时的速度，使其看起来更加真实 二十五、移动端 网站 说明 腾讯移动Web前端知识库 Mars - mobile needs a hero Mobi Tips TGideas mobileTech jtyjty99999-Alibaba，收集移动端开发所需要的一些资源与小技巧 无线Web开发经验谈 支付宝 Mobile Web Favorites hoosin 移动web资源整理 白树，就职微信支付，负责移动端产品，擅长小程序、H5前端开发 Zepto.js API 中文版 愚人码头,一些可选功能是专门针对移动端浏览器的 Framework7 阿里他她，特色的HTML框架 可以创建精美的iOS应用 SUI Mobile 阿里他她，一套基于 Framework7 开发的UI库 Swiper 开源、免费、强大的移动端触摸滑动插件 二十六、开发平台 网站 简介 JSFiddle 一款在线的代码编辑器,通过流行的JS框架创建自定义的环境,以简化JS代码 JSBin Collaborative JavaScript Debugging BabelJS 一个 JavaScript 编译器 RunJS 在线编辑、展示、分享、交流你的 JavaScript 代码 JSDM 一个WEB前端在线编辑器，可同时编辑HTML、CSS、JAVASCRIPT代码，并即时预览！ CodePen 面向前端设计人员和开发人员的社交开发环境 IDeone 一个在线编译器和调试工具，它允许您编译源代码并在线执行超过60种编程语言 HCODE 一个在线代码测试、托管、分享的工具，方便与别人一起调试、分享代码，具有代码高亮、一键代码格式化、贴心的快捷键等功能。 Thimble 一个在线代码编辑器，用它可以很轻松地创建和发布一个您自己的网页，一切伴随着 HTML、CSS 和 JavaScript。 二十七、在线工具 网站 简介 CanIUse 查看浏览器版本对HTML5和CSS3的支持情况 ECMAScript 6 compatibility table ECMAScript 6兼容性表 CSS Validation Service W3C CSS 验证服务 BROWSERHACKS browser specific CSS and JavaScript hacks 二十八、正则表达式 网站 简介 正则表达式 MDN MDN Web 文档 RegExp对象 阮一峰 正则的扩展 阮一峰 进阶正则表达式 小胡子哥 ( Barret Lee ) 正则表达式30分钟入门教程 deerchao 正则表达式前端使用手册 路易斯 JS正则表达式元字符 思否 小弟调调 二十九、CDN 网站 简介 百度静态资源公共库 稳定，快速，全面，开源的国内CDN加速服务。 360网站卫士常用前端公共库CDN服务 常用前端公共库以及和谐使用Google公共库&amp;字体库的调用方法 前端库CDN服务 微信，主要包括一些常用的 JS 库，CSS库，甚至是SWF文件。 BootCDN Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务 TAONPM 淘宝 NPM 镜像,可以用此代替官方版本(只读) Staticfile CDN 免费、快速、开放的 CDN 服务 jQuery CDN 最新的稳定版本 三十、API 网站 简介 OverAPI.com Collecting All Cheat Sheets 常用API文档索引 开源中国社区 在线API文档]]></content>
    
  </entry>
  <entry>
    <title><![CDATA[Javascript基础-执行机制]]></title>
    <url>%2FJavascript%E5%9F%BA%E7%A1%80-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    
      <content type="text"><![CDATA[try 里面放 return，finally 里的代码会不会执行，理解其内部机制会执行,在方法返回给调用者前执行,因为如果存在finally代码块,try中的return语句不会立马返回给调用者,而是记录下返回值待finally代码块执行完毕之后再返回; 123456789101112// return 执行了但是没有立即返回，而是先执行了 finallyfunction kaimo() &#123; try &#123; return 0 &#125; catch (err) &#123; console.log(err) &#125; finally &#123; console.log('a') &#125;&#125;console.log(kaimo()) // a 0 123456789101112// finally 中的 return 覆盖了 try 中的 return。function kaimo() &#123; try &#123; return 0 &#125; catch (err) &#123; console.log(err) &#125; finally &#123; return 1 &#125;&#125;console.log(kaimo()) // 1 注意1、不管有木有出现异常，finally 块中代码都会执行；2、当 try 和 catch 中有 return 时，finally 仍然会执行；3、finally 是在 return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管 finally 中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在 finally 执行前确定的；4、finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。 参考资料： 重学前端学习笔记（二十）–try 里面放 return，finally 还会执行吗？ JavaScript 如何实现异步编程1.回调函数但会导致两个问题:缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符缺乏可信任性： 控制反转导致的一系列信任问题2.PromisePromise 是基于 PromiseA+规范的实现，它很好的解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来。3.生成器函数 Generator使用 Generator，可以让我们用同步的方式来书写代码，解决了顺序性的问题，但是需要手动去控制 next(...)，将回调成功返回的数据送回 JavaScript 主流程中。4.Async/AwaitAsync/Await 结合了 Promise 和 Generator，在 await 后面跟一个 Promise，它会自动等待 Promise 的决议值，解决了 Generator 需要手动控制 next(...)执行的问题，真正实现了用同步的方式书写异步代码。5.发布订阅模式在 JavaScript 中应用非常广泛，比如一些前端框架比如 React,Vue 等，都有使用这一设计模式，nodejs 使用的就更多了。使用发布订阅模式的好处是事件集中管理，修改方便，缺点就是，代码可读性下降，事件容易冲突。 简单实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//async_Event.js//单对象写法 Event 就相当于事件中心const Event = (function() &#123; //使用闭包的好处 : 把EventPool私有化，外界无法访问EventPool const EventPool = new Map() //使用es6 map来存 event，callback 键值对 const isFunction = func =&gt; typeof func === 'function' const on = (event, callback) =&gt; &#123; //注册事件 EventPool.get(event) || EventPool.set(event, []) if (isFunction(callback)) &#123; EventPool.get(event).push(callback) &#125; else &#123; throw new Error('callback not is function') &#125; &#125; const addEventListenr = (event, callback) =&gt; &#123; //on方法别名 on(event, callback) &#125; const emit = (event, ...args) =&gt; &#123; //触发(发布)事件 //让事件的触发为一个异步的过程，即排在同步代码后执行 //也可以setTimeout(fn,0) Promise.resolve().then(() =&gt; &#123; let funcs = EventPool.get(event) if (funcs) &#123; funcs.forEach(f =&gt; f(...args)) &#125; else &#123; throw new Error(`$&#123;event&#125; not register`) &#125; &#125;) &#125; const send = (event, ...args) =&gt; &#123; //emit方法别名 emit(event, ...args) &#125; const removeListener = event =&gt; &#123; //删除事件 Promise.resolve(() =&gt; &#123; //删除事件也为异步的过程 if (event) &#123; EventPool.delete(event) &#125; else &#123; throw new Error(`$&#123;event&#125; not register`) &#125; &#125;) &#125; return &#123; on, emit, addEventListenr, send &#125;&#125;)() 简单使用 123456789//注册事件，名为eventEvent.on('event', data =&gt; &#123; console.log(data) &#125;);setTimeout(() =&gt; &#123; Event.emit('event','hello wrold') &#125;，1000);//1s后触发事件，输出hello world 宏任务和微任务分别有哪些宏队列，macrotask，也叫 tasks。 一些异步任务的回调会依次进入 macro task queue，等待后续被调用，这些异步任务包括： 123456setTimeoutsetIntervalsetImmediate (Node独有)requestAnimationFrame (浏览器独有)I&#x2F;OUI rendering (浏览器独有) 微队列，microtask，也叫 jobs。 另一些异步任务的回调会依次进入 micro task queue，等待后续被调用，这些异步任务包括： 1234process.nextTick (Node独有)PromiseObject.observeMutationObserver 使用 Promise 实现串行1234567891011// 一个 promise 的 functionfunction delay(time) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`wait $&#123;time&#125;s`) setTimeout(() =&gt; &#123; console.log('execute') resolve() &#125;, time * 1000) &#125;)&#125;const arr = [3, 4, 5] 1.reduce 123arr.reduce((s, v) =&gt; &#123; return s.then(() =&gt; delay(v))&#125;, Promise.resolve()) 2.async + 循环 + await 12345;(async function() &#123; for (const v of arr) &#123; await delay(v) &#125;&#125;)() 3.普通循环 1234let p = Promise.resolve()for (const i of arr) &#123; p = p.then(() =&gt; delay(i))&#125; 4.递归 12345function dispatch(i, p = Promise.resolve()) &#123; if (!arr[i]) return Promise.resolve() return p.then(() =&gt; dispatch(i + 1, delay(arr[i])))&#125;dispatch(0) EventLoop 是什么event loop 是一个执行模型，在不同的地方有不同的实现。浏览器和 NodeJS 基于不同的技术实现了各自的 Event Loop。 浏览器的 Event Loop这张图将浏览器的 Event Loop 完整的描述了出来，我来讲执行一个 JavaScript 代码的具体流程： 123456789101.执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；2.全局Script代码执行完毕后，调用栈Stack会清空；3.从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；4.继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；5.microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；6.取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；7.执行完毕后，调用栈Stack为空；8.重复第3-7个步骤；9.重复第3-7个步骤；10....... 这里归纳 3 个重点： 1.宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务； 2.微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空； 3.图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。 测试一下你是否掌握了: 123456789101112131415161718192021console.log(1)setTimeout(() =&gt; &#123; console.log(2) Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;)&#125;)new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(5)&#125;).then(data =&gt; &#123; console.log(data)&#125;)setTimeout(() =&gt; &#123; console.log(6)&#125;)console.log(7) 这里结果会是什么呢？运用上面了解到的知识，先自己做一下试试看。 12345678&#x2F;&#x2F; 正确答案1475236 参考资料： 带你彻底弄懂 Event Loop 如何解决页面加载海量数据而页面不卡顿1.分治思想，在一定的时间内多次加载数据，直至渲染完成，使用 window.requestAnimationFrame 和 document.createDocumentFragment() 实现 2.局部显示，毕竟用户能看到的就一屏内容，监听用户的滚动行为，改变显示元素，可使 DOM 结构最简单化 题目：页面上有个空的无序列表节点 ul ，其 id 为 list-with-big-data ，现需要往列表插入 10w 个 li ，每个列表项的文本内容可自行定义，且要求当每个 li 被单击时，通过 alert 显示列表项内的文本内容 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;页面加载海量数据&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="list-with-big-data"&gt; 100000 数据 &lt;/ul&gt; &lt;script&gt; // 此处添加你的代码逻辑 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解决方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748;(function() &#123; const ulContainer = document.getElementById('list-with-big-data') // 防御性编程 if (!ulContainer) &#123; return &#125; const total = 100000 // 插入数据的总数 const batchSize = 4 // 每次批量插入的节点个数，个数越多，界面越卡顿 const batchCount = total / batchSize // 批处理的次数 let batchDone = 0 // 已完成的批处理个数 function appendItems() &#123; // 使用 DocumentFragment 减少 DOM 操作次数，对已有元素不进行回流 const fragment = document.createDocumentFragment() for (let i = 0; i &lt; batchSize; i++) &#123; const liItem = document.createElement('li') liItem.innerText = batchDone * batchSize + i + 1 fragment.appendChild(liItem) &#125; // 每次批处理只修改 1 次 DOM ulContainer.appendChild(fragment) batchDone++ doAppendBatch() &#125; function doAppendBatch() &#123; if (batchDone &lt; batchCount) &#123; // 在重绘之前，分批插入新节点 window.requestAnimationFrame(appendItems) &#125; &#125; // kickoff doAppendBatch() // 使用 事件委托 ，利用 JavaScript 的事件机制，实现对海量元素的监听，有效减少事件注册的数量 ulContainer.addEventListener('click', function(e) &#123; const target = e.target if (target.tagName === 'LI') &#123; alert(target.innerText) &#125; &#125;)&#125;)()]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础-作用域和闭包]]></title>
    <url>%2FJavascript%E5%9F%BA%E7%A1%80-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    
      <content type="text"><![CDATA[理解词法作用域和动态作用域动态作用域不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。作用域链式基于调用栈的，而不是代码中的作用域嵌套。 需要明确的是，JavaScript并不具有动态作用域。它只有词法作用域，简单明了。但是this机制某种程度上很像动态作用域。 123456789function foo()&#123; console.log(a);//2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar(); 理解 JavaScript 的作用域和作用域链作用域链的定义：函数在调用参数时会从函数内部到函数外部逐个”搜索“参数，一直找到参数为止，如果没有声明就返回null，声明了没有赋值就返回undefined，就像沿着一条链子一样去搜索，这就是作用域的链式调用。 javascrip的全局变量的作用域是全局的，在代码的任何地方都是有定义的。函数的参数和局部变量只在函数体内有定义。在函数内部如果调用一个变量，就会发生上述的作用域链式调用的过程。 this的原理以及几种不同使用场景的取值1.作为对象方法调用 1234567var test = &#123; a:0, b:0 get:function()&#123; return this.a; &#125;&#125; 2.作为函数调用函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。 3.作为构造函数调用javaScript 支持面向对象式编程，与主流的面向对象式编程语言不同，JavaScript 并没有类（class）的概念，而是使用基于原型（prototype）的继承方式。相应的，JavaScript 中的构造函数也很特殊，如果不使用 new调用，则和普通函数一样。作为又一项约定俗成的准则，构造函数以大写字母开头，提醒调用者使用正确的方式调用。如果调用正确，this 绑定到新创建的对象上。 1234function Point(x, y)&#123; this.x = x; this.y = y; &#125; 4.在call或者apply，bind中调用让我们再一次重申，在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。很多 JavaScript 中的技巧以及类库都用到了该方法。 123456789101112function Point(x, y)&#123; this.x = x; this.y = y; this.moveTo = function(x, y)&#123; this.x = x; this.y = y; &#125; &#125; var p1 = new Point(0, 0); var p2 = &#123;x: 0, y: 0&#125;; p1.moveTo(1, 1); p1.moveTo.apply(p2, [10, 10]) 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用原理：闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 作用：闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 应用：1. 匿名自执行函数 2. 结果缓存 3. 封装局部变量 理解堆栈溢出和内存泄漏的原理，如何防止1、内存泄露：是指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄露过多的话，就会导致后面的程序申请不到内存。因此内存泄露会导致内部内存溢出 2、堆栈溢出：由于过多的函数调用，导致调用堆栈无法容纳这些调用的返回地址，一般在递归中产生。堆栈溢出很可能由无限递归（Infinite recursion）产生，但也可能仅仅是过多的堆栈层级 3、在一些编程软件中，比如c语言中，需要使用malloc来申请内存空间，再使用free释放掉，需要手动清除。而js中是有自己的垃圾回收机制的，一般常用的垃圾收集方法就是标记清除。 标记清除法：在一个变量进入执行环境后就给它添加一个标记：进入环境，进入环境的变量不会被释放，因为只要“执行流”进入响应的环境，就可能用到他们。当变量离开环境后，则将其标记为“离开环境”。 4、常见的内存泄露的原因： 123全局变量引起的内存泄露闭包没有被清除的计时器 5、解决方法： 123减少不必要的全局变量减少闭包的使用（因为闭包会导致内存泄露）避免死循环的发生 如何处理循环的异步操作在实际开发中，异步总是不可逃避的一个问题，尤其是Node.js端对于数据库的操作涉及大量的异步，同时循环又是不可避免的，想象一下一次一个数据组的存储数据库就是一个典型的循环异步操作，而在循环之后进行查询的话就需要确保之前的数据组已经全部存储在了数据库中。可以得到关于循环的异步操作主要有两个问题：1.如何确保循环的所有异步操作完成之后执行某个其他操作2.循环中的下一步操作依赖于前一步的操作，如何解决 ———————分割线———————-方法一：设置一个flag，在每个异步操作中对flag进行检测 1234567891011121314151617181920212223242526272829303132var func1 = function(callback)&#123; setTimeout(function()&#123; console.log('foo'); typeof(callback) !== 'function' || callback(); &#125;, 499);&#125;;var func2 = function(callback)&#123; setTimeout(function()&#123; console.log('bar'); typeof(callback) !== 'function' || callback(); &#125;, 500);&#125;;var func3 = function(callback)&#123; setTimeout(function()&#123; console.log('foobar'); typeof(callback) !== 'function' || callback(); &#125;, 501);&#125;;var func_arr = [func1, func2, func3];let len = func_arr.length;let flag = 0;for(let i = 0; i &lt; len; i++) &#123; func_arr[i](function()&#123; flag++; if(flag === len) &#123; console.log('job finished'); &#125; &#125;)&#125; 方法二：将所有的循环放在一个promise中，使用then处理 1234567891011121314151617// promisify those callback functionsvar promisify = function(func)&#123; return function()&#123; return new Promise(function(resolve)&#123; func(resolve); &#125;); &#125;&#125;// array can be infinitely longvar func_arr = [promisify(func1), promisify(func2), promisify(func3)];func_arr.reduce(function(cur, next) &#123; return cur.then(next);&#125;, Promise.resolve()).then(function() &#123; console.log('job finished');&#125;); 方法三：使用递归，在异步操作完成之后调用下一次异步操作 12345678910111213function loop(i) &#123; if (i != func_arr.length) &#123; return func_arr[i]() .then(function() &#123; return loop(i+1); &#125;); &#125; return Promise.resolve(i);&#125;loop(0).then(function(loop_times)&#123; console.log('job finished');&#125;); 方法四：使用async和await 12345async function loop() &#123; for(let i = 0; i &lt; len; i++) &#123; await func_arr[i](); &#125;&#125;]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础-原型和原型链]]></title>
    <url>%2FJavascript%E5%9F%BA%E7%A1%80-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    
      <content type="text"><![CDATA[理解原型设计模式以及 JavaScript 中的原型规则原型链：每一个实例对象都有一个__proto__属性（隐式原型），在js内部用来查找原型链；每一个构造函数都有prototype属性（显示原型），用来显示修改对象的原型，实例.__proto__=构造函数.prototype=原型。原型链的特点就是：通过实例.__proto__查找原型上的属性，从子类一直向上查找对象原型的属性，继而形成一个查找链即原型链。 instanceof 的底层实现原理，手动实现一个 instanceof简单说就是判断实例对象的__proto__是不是强等于对象的prototype属性，如果不是继续往原型链上找，直到 __proto__ 为 null 为止。 12345678910111213//obj 表示实例对象，object 表示对象function instanceOf(obj, object) &#123; var O = object.prototype; obj = obj.__proto__; while (true) &#123; if (obj === null) return false; if (O === obj) // 这里重点：当 O 严格等于 obj 时，返回 true return true; obj = obj.__proto__; &#125; &#125; 理解 JavaScript 的执行上下文栈，可以应用堆栈信息快速定位问题执行上下文 就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文总共有三种类型：全局执行上下文, 函数执行上下文, Eval 函数执行上下文 执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。 实现继承的几种方式以及他们的优缺点1.原型链继承 123456789101112131415161718192021//父类，带属性 function Super()&#123; this.flag = true; &#125; //为了提高复用性，方法绑定在父类原型属性上 Super.prototype.getFlag = function()&#123; return this.flag; &#125; //来个子类 function Sub()&#123; this.subFlag = false; &#125; //实现继承 Sub.prototype = new Super; //给子类添加子类特有的方法，注意顺序要在继承之后 Sub.prototype.getSubFlag = function()&#123; return this.subFlag; &#125; //构造实例 var es5 = new Sub; 缺点：构造函数原型上的属性在所有该构造函数构造的实例上是共享的，即属性没有私有化，原型上属性的改变会作用到所有的实例上。 2.构造函数继承在构造子类构造函数时内部使用call或apply来调用父类的构造函数 1234567891011function Super()&#123; this.flag = true; &#125; function Sub()&#123; Super.call(this) //如果父类可以需要接收参数，这里也可以直接传递 &#125; var obj = new Sub(); obj.flag = flase; var obj_2 = new Sub(); console.log(obj.flag) //依然是true，不会相互影响 优缺点：实现了属性的私有化，但是子类无法访问父类原型上的属性。 3.组合继承利用构造函数和原型链的方法，可以比较完美的实现继承 12345678910111213141516function Super()&#123; this.flag = true; &#125; Super.prototype.getFlag = function()&#123; return this.flag; //继承方法 &#125; function Sub()&#123; this.subFlag = flase // 第一次调用父类构造函数 Super.call(this) //继承属性 &#125; // 第二次调用父类构造函数Sub.prototype = new Super; var obj = new Sub(); Sub.prototype.constructor = Sub; 这里还有个小问题，Sub.prototype = new Super; 会导致Sub.prototype的constructor指向Super;然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：Sub.prototype.constructor = Sub; 4.寄生继承即将Sub.prototype=new Super改为Sub.prototype=Object.create(Supper.prototype)，避免了组合继承中构造函数调用了两次的弊端。 可以描述 new 一个对象的详细过程，手动实现一个 new 操作符过程当我们new一个构造函数，得到的实例继承了构造器的构造属性以及原型上的属性。在《JavaScript模式》这本书中，new的过程说的比较直白，当我们new一个构造器，主要有三步：1.以构造器的prototype属性为原型，创建新对象；2.将this(也就是上一句中的新对象)和调用参数传给构造器，执行；3.如果构造器没有手动返回对象，则返回第一步创建的对象 实现 12345function myNew(Obj,...args)&#123; var obj = Object.create(Obj.prototype);// 使用指定的原型对象及其属性去创建一个新的对象 Obj.apply(obj,args); // 绑定 this 到obj, 设置 obj 的属性 return obj; // 返回实例&#125; 理解 es6 class 构造以及继承的底层实现原理ES6中通过class关键字，定义类 123456789class Parent &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; speakSomething()&#123; console.log("I can speek chinese"); &#125;&#125; 经过babel转码之后 1234567891011121314151617181920212223242526272829303132333435363738394041var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125;&#125;var Parent = function () &#123; function Parent(name, age) &#123; _classCallCheck(this, Parent); this.name = name; this.age = age; &#125; _createClass(Parent, [&#123; key: "speakSomething", value: function speakSomething() &#123; console.log("I can speek chinese"); &#125; &#125;]); return Parent;&#125;(); 可以看到ES6类的底层还是通过构造函数去创建的。 通过ES6创建的类，是不允许你直接调用的。在ES5中，构造函数是可以直接运行的，比如Parent()。但是在ES6就不行。我们可以看到转码的构造函数中有_classCallCheck(this, Parent)语句,这句话是防止你通过构造函数直接运行的。你直接在ES6运行Parent(),这是不允许的,ES6中抛出Class constructor Parent cannot be invoked without &#39;new&#39;错误。转码后的会抛出Cannot call a class as a function.我觉得这样的规范挺好的，能够规范化类的使用方式。 转码中_createClass方法，它调用Object.defineProperty方法去给新创建的Parent添加各种属性。defineProperties(Constructor.prototype, protoProps)是给原型添加属性。如果你有静态属性，会直接添加到构造函数上defineProperties(Constructor, staticProps)。但是貌似并没有用到，下面可以证明. 这两个流程走下来，其实就创建了一个类。 上面讲的是创建一个类的过程，那ES6如何实现继承的呢？还是上面的例子，这次我们给Parent添加静态属性，原型属性，内部属性 1234567891011121314151617181920212223242526class Parent &#123; static height = 12 constructor(name,age)&#123; this.name = name; this.age = age; &#125; speakSomething()&#123; console.log("I can speek chinese"); &#125;&#125;Parent.prototype.color = 'yellow'//定义子类，继承父类class Child extends Parent &#123; static width = 18 constructor(name,age)&#123; super(name,age); &#125; coding()&#123; console.log("I can code JS"); &#125;&#125;var c = new Child("job",30);c.coding() 转码之后的代码变成了这样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); &#125; return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self;&#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== "function" &amp;&amp; superClass !== null) &#123; throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125;&#125;var Parent = function () &#123; function Parent(name, age) &#123; _classCallCheck(this, Parent); this.name = name; this.age = age; &#125; _createClass(Parent, [&#123; key: "speakSomething", value: function speakSomething() &#123; console.log("I can speek chinese"); &#125; &#125;]); return Parent;&#125;();Parent.height = 12;Parent.prototype.color = 'yellow';//定义子类，继承父类var Child = function (_Parent) &#123; _inherits(Child, _Parent); function Child(name, age) &#123; _classCallCheck(this, Child); return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name, age)); &#125; _createClass(Child, [&#123; key: "coding", value: function coding() &#123; console.log("I can code JS"); &#125; &#125;]); return Child;&#125;(Parent);Child.width = 18;var c = new Child("job", 30);c.coding(); 我们可以看到，构造类的方法都没变，只是添加了_inherits核心方法来实现继承，下面我们就看下这个方法做了什么？ 首先是判断父类的类型，然后 12345678subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); 这段代码翻译下来就是 1234function F()&#123;&#125;F.prototype = superClass.prototypesubClass.prototype = new F()subClass.prototype.constructor = subClass 接下来subClass.proto = superClass_inherits核心思想就是下面两句 12subClass.prototype.__proto__ = superClass.prototypesubClass.__proto__ = superClass 一图胜千言 那为什么这样一倒腾，它就实现了继承了呢?首先 subClass.prototype.__proto__ = superClass.prototype保证了c instanceof Parent是true,Child的实例可以访问到父类的属性，包括内部属性，以及原型属性。其次，subClass.__proto__ = superClass，保证了Child.height也能访问到，也就是静态方法。 subClass.__proto__ = superClass不是很好理解，可以通过下面的方式理解 123function A()&#123;&#125;var a = new A()a.__proto__ = A.prototype a是一个实例，A.prototype是构造方法的原型。通过这种方式，那么a就可以访问A.prototype上面的方法。 那把 subClass类比成 a，superClass类比成A.prototype，那是不是subClass可以直接访问 superClass的静态属性，静态方法了。 参考资料： ES6类以及继承的实现原理]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础-变量和类型]]></title>
    <url>%2FJavascript%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%2F</url>
    
      <content type="text"><![CDATA[变量和类型JavaScript规定了几种语言类型Undefined Null Boolean String Number Symbol Object 为什么有的编程规范要求用 void 0 代替 undefined？ undefined是全局对象的一个属性，也就是说，它是全局作用域中的一个变量，undefined的最初值就是原始数据类型undefined。ES5之后的标准中，规定了全局变量下的undefined值为只读，不可改写的，但是局部变量中依然可以对之进行改写。而void 0无论什么时候都是返回undefined，这样来看，使用void 0来代替undefined就比较稳妥，不会出错 123456console.log(window.undefined == void 0); // truefunction changeUndefined () &#123; var undefined = 1; console.log(undefined);&#125;changeUndefined(); // 1 JavaScript对象的底层数据结构是什么js基本类型数据都是直接按值存储在栈中的(Undefined、Null、不是new出来的布尔、数字和字符串)，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。 js引用类型数据被存储于堆中 (如对象、数组、函数等，它们是通过拷贝和new出来的）。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据 参考资料：再谈js对象数据结构底层实现原理 Symbol类型在实际开发中的应用、可手动实现一个简单的SymbolES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。 symbol类型的 key 不能被 Object.keys 和 for..of 循环枚举。因此可当作私有变量使用。 12345678let mySymbol = Symbol('key');// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;; 完整实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(function() &#123; var root = this; var generateName = (function()&#123; var postfix = 0; return function(descString)&#123; postfix++; return '@@' + descString + '_' + postfix &#125; &#125;)() var SymbolPolyfill = function Symbol(description) &#123; if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor'); var descString = description === undefined ? undefined : String(description) var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__; &#125;, valueOf: function() &#123; return this; &#125; &#125;) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerable: false, configurable: false &#125;, '__Name__': &#123; value: generateName(descString), writable: false, enumerable: false, configurable: false &#125; &#125;); return symbol; &#125; var forMap = &#123;&#125;; Object.defineProperties(SymbolPolyfill, &#123; 'for': &#123; value: function(description) &#123; var descString = description === undefined ? undefined : String(description) return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString); &#125;, writable: true, enumerable: false, configurable: true &#125;, 'keyFor': &#123; value: function(symbol) &#123; for (var key in forMap) &#123; if (forMap[key] === symbol) return key; &#125; &#125;, writable: true, enumerable: false, configurable: true &#125; &#125;); root.SymbolPolyfill = SymbolPolyfill;&#125;)() 参考资料： ES6 系列之模拟实现 Symbol 类型 JavaScript中的变量在内存中的具体存储形式JavaScript 中的变量分为基本类型和引用类型: 基本类型: 保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问 引用类型: 保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 参考资料：JavaScript中的变量在内存中的具体存储形式 基本类型对应的内置对象，以及他们之间的装箱拆箱操作String(), Number(), Boolean() 装箱：就是把基本类型转变为对应的对象。装箱分为隐式和显示 12345678910// 隐式装箱： 每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。// 在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。// 这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。let num=123;num.toFixed(2); // '123.00'//上方代码在后台的真正步骤为var c = new Number(123);c.toFixed(2);c = null;// 显式装箱: 通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。var obj = new String('123'); 拆箱: 拆箱与装箱相反，把对象转变为基本类型的值。 1234 Number([1]); //1// 转换演变：[1].valueOf(); // [1];[1].toString(); // '1';Number('1'); //1 参考资料：JavaScript 基本类型的装箱与拆箱 null和undefined的区别Number 转换的值不同，Number(null) 输出为 0, Number(undefined) 输出为 NaNnull 表示一个值被定义了，但是这个值是空值undefined 表示缺少值，即此处应该有值，但是还没有定义 typeof 结果不同 123typeof undefined // "undefined"typeof null // "object"，尽管返回 `object`，但他依旧是一个原始值，这是 JavaScript 在实现上的一个 bug。typeof NaN // "number" 至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型1.typeof —— 返回给定变量的数据类型，可能返回如下字符串： 12345678&#39;undefined&#39;——Undefined&#39;boolean&#39;——Boolean&#39;string&#39;——String&#39;number&#39;——Number&#39;symbol&#39;——Symbol&#39;object&#39;——Object &#x2F; Null （Null 为空对象的引用）&#39;function&#39;——Function&#x2F;&#x2F; 对于一些如 error() date() array()无法判断，都是显示object类型 2.instanceof 检测 constructor.prototype 是否存在于参数 object 的原型链上，是则返回 true，不是则返回 false。 12345alert([1,2,3] instanceof Array) // truealert(new Date() instanceof Date) // truealert(function()&#123;this.name="22";&#125; instanceof Function) //truealert(function()&#123;this.name="22";&#125; instanceof function) //false// instanceof 只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。 3.constructor —— 返回对象对应的构造函数。 1234567891011121314alert(&#123;&#125;.constructor === Object); =&gt; truealert([].constructor === Array); =&gt; truealert('abcde'.constructor === String); =&gt; truealert((1).constructor === Number); =&gt; truealert(true.constructor === Boolean); =&gt; truealert(false.constructor === Boolean); =&gt; truealert(function s()&#123;&#125;.constructor === Function); =&gt; truealert(new Date().constructor === Date); =&gt; truealert(new Array().constructor === Array); =&gt; truealert(new Error().constructor === Error); =&gt; truealert(document.constructor === HTMLDocument); =&gt; truealert(window.constructor === Window); =&gt; truealert(Symbol().constructor); =&gt; undefined // null 和 undefined 是无效的对象，没有 constructor，因此无法通过这种方式来判断。 4.Object.prototype.toString() 默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，是一个字符串，其中 Xxx 就是对象的类型。 1234567891011121314151617Object.prototype.toString.call(new Date);//[object Date]Object.prototype.toString.call(new String);//[object String]Object.prototype.toString.call(Math);//[object Math]Object.prototype.toString.call(undefined);//[object Undefined]Object.prototype.toString.call(null);//[object Null]Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(123) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用// 比较全面 优缺点 typeof instanceof constructor Object.prototype.toString.call 优点 使用简单 能检测出引用类型 基本能检测所有的类型（除了null和undefined） 检测出所有的类型 缺点 只能检测出基本类型（除了null） 不能检测出基本类型，且不能跨iframe constructor易被修改，也不能跨iframe IE6下，undefined和null均为Object 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用一、数字运算符做+操作时，数字被隐式转换成字符串，实际上做的是字符串连接操作。 做除了加法以外的运算操作时，字符串被隐式转换成数字，实际上做的是数值计算。 二、.点号操作符数字、字符串等直接量在做.操作调用方法时，隐式地将类型转换成对象。 三、if语句if()括号里的表达式部分会被隐式转化为布尔类型进行判别。null，&quot;&quot;，undefinded, 0, false 都会被转化为 false 四、==等号-object array map set 参数 结果 undefined “undefined” null “null” boolean “true” 或者 “false” number 数字作为字符串。比如，”1.765” string 无需转换 [] “” [5,2] “5,2” {} “[object Object]” Symbol() “Symbol()” 参考资料：JavaScript进阶系列-类型转换、隐式类型转换 出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法1.精度丢失原因，说是 JavaScript 使用了 IEEE 754 规范，二进制储存十进制的小数时不能完整的表示小数 2.能够表示的最大数字 Number.MAX_VALUE 等于 1.7976931348623157e+308 ,最大安全数字 Number.MAX_SAFE_INTEGER 等于 9007199254740991 3.处理大数字: BigNumber 4.避免精度丢失: 把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数） 参考资料：js数字位数太大导致参数精度丢失问题]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工程师自检清单]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%2F</url>
    
      <content type="text"><![CDATA[讲道理，前端开发的历史并不长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。尤其是三大框架逐渐成熟，基本三分天下，前端圈子很大部分也主要围绕他们发展。 winter在他的《重学前端》课程中提到： 到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。 因为前端行业这几年的蓬勃发展，很多同学都是都是自学甚至转行过来的，毕竟相较服务端，前端入门相对简单，而且伴随三大框架成熟的红利，基本只要熟悉一些简单的API就可以上手做项目，虽然开发便捷了，但是这往往也成为了限制自身发展的瓶颈。 然而停留在这个会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少培训机构，但是这么多的课程，哪些对是真的对你有用的，哪些只是长篇大论，盲目的投入到这些学习资料中，你会发现知识留存率很低，而且看的越多不懂的越多，只会让人产生焦虑。 所以，就像在学校中学习，你拿起书的第一件事情，应该是先看大纲，了解这本书会带给你什么。同理，在学习之前，你需要建立自己的知识体系。它能帮助你更系统性的学习，树立好明确的目标。 而我，会把我工作和学习中接触到的知识全部归纳到我的知识体系中，将一个一个分散的点串联成面。 下面我会把我的清单分享给大家(这里的一些内容有我工作中经历的，也有一些是我自己需要补足的地方，这次偷个懒，先晒这一份思维导图，后面的文章会详细介绍) 如果你有哪些我没归纳到的点，欢迎在评论区告诉我。]]></content>
    
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10分钟上线个人博客]]></title>
    <url>%2F10%E5%88%86%E9%92%9F%E4%B8%8A%E7%BA%BF%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    
      <content type="text"><![CDATA[没有手撸过个人网站的程序员不是一个好的程序猿，可是！强撸灰飞湮灭！为了自己的身体健康，还是少撸为妙！不要998，也不要98，完全免费，hexo你直接带回家。通过hexo，可以快速构建个人博客，并搭建到 github 上供他人访问，我们开始吧！ 新建仓库 首先要创建一个github账号 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建github page才会生效。 安装hexo hexo不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具 安装 1npm install -g hexo 新建一个目录，执行初始化 123mkdir blogcd bloghexo init 文件/文件夹 说明 _config.yml 配置文件 public 生成的静态文件，这个目录最终会发布到服务器 scaffolds 一些通用的markdown模板 source 编写的markdown文件，_drafts草稿文件，_posts发布的文章 themes 博客的模板 1hexo s 在浏览器中访问：http://localhost:4000 就可以看到你本定运行的页面了 创建新文章1234// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。// &lt;title&gt; 为文章标题// 如 hexo new FirstBloodhexo new [layout] &lt;title&gt; 找到自己刚刚新建的文件进去编辑，遵循markdown语法 更换主题皮肤默认的主题不是很好看，我们可以去官网下载, 甚至可以自己做 12345# 下载到themes文件夹下git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia yilia# 修改 _config.yml 配置theme: yilia 然后重新启动服务 发布先安装git插件： 1npm install hexo-deployer-git --save 修改_config.yml中的git配置 1234deploy: type: git repo: https://github.com/yourname.github.io branch: master 当然，只是这样肯定不行，你要确保你本地能git push到服务端，所以需要配置本地的ssh公钥(id_rsa.pub)配置到github上。 发布 12hexo cleanhexo delpoy demo预览https://majinhui04.github.io/]]></content>
    
      <tags>
        <tag>周边</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    
  </entry>
</search>
